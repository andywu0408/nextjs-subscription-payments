

DO NOT EVER ADD “WORKSPACE IN FILE PATH, start with src folder!” DO NOT ADD EM DASH! MUST CITE 5 real files in each section especially ideal answer!

Make sure to obey these 100% “. 

-  All answers should have  5+ meaningful sentences and clear as well 
- All sections must reference at least 5 files with file’s absolute path but without the “WORKSPACE” in the directory url
- MODEL A and MODEL B RESPONSES ARE PROVIDED. IN 2. And 3. 
- DO NOt ADD ANY EM DASH!!!
- Adding a few file references in the feedback section could strength the answer.
- The ideal response could benefit from a dedicated file-list section summarizing all referenced files together.
- Adding separate strength and weakness points inside summaries would enhance readability and make the evaluation feel more complete.


1.new task, question is:What design patterns are used in the web app for dependency injection in this codebase?




———MODEL A RESPONES IS BELOW!!!!——————
2.here is model A's response: 
bash
command
find /tmp/inputs/nextjs-subscription-payments -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) | head -50
output
/tmp/inputs/nextjs-subscription-payments/types_db.ts
/tmp/inputs/nextjs-subscription-payments/middleware.ts
/tmp/inputs/nextjs-subscription-payments/tailwind.config.js
/tmp/inputs/nextjs-subscription-payments/next-env.d.ts
/tmp/inputs/nextjs-subscription-payments/postcss.config.js
/tmp/inputs/nextjs-subscription-payments/components/icons/GitHub.tsx
/tmp/inputs/nextjs-subscription-payments/components/icons/Logo.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LogoCloud/LogoCloud.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LogoCloud/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Button/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Button/Button.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LoadingDots/LoadingDots.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LoadingDots/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/EmailForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/NameForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/toaster.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/use-toast.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/toast.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Input/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Input/Input.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Card/Card.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Card/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/PasswordSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/OauthSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/Signup.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/UpdatePassword.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/Separator.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/EmailSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/ForgotPassword.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Footer/Footer.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Footer/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navbar.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navlinks.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/index.ts
/tmp/inputs/nextjs-subscription-payments/utils/helpers.ts
/tmp/inputs/nextjs-subscription-payments/utils/cn.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/settings.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts
/tmp/inputs/nextjs-subscription-payments/app/layout.tsx


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments
output
Here're the files and directories up to 2 levels deep in /tmp/inputs/nextjs-subscription-payments, excluding hidden items and node_modules:
2.3M	/tmp/inputs/nextjs-subscription-payments
1.5K	/tmp/inputs/nextjs-subscription-payments/LICENSE
16K	/tmp/inputs/nextjs-subscription-payments/README.md
81K	/tmp/inputs/nextjs-subscription-payments/app
1.5K	/tmp/inputs/nextjs-subscription-payments/app/account
3.5K	/tmp/inputs/nextjs-subscription-payments/app/api
3.0K	/tmp/inputs/nextjs-subscription-payments/app/auth
1.5K	/tmp/inputs/nextjs-subscription-payments/app/layout.tsx
66K	/tmp/inputs/nextjs-subscription-payments/app/opengraph-image.png
1.0K	/tmp/inputs/nextjs-subscription-payments/app/page.tsx
4.5K	/tmp/inputs/nextjs-subscription-payments/app/signin
62K	/tmp/inputs/nextjs-subscription-payments/components
512	/tmp/inputs/nextjs-subscription-payments/components.json
2.5K	/tmp/inputs/nextjs-subscription-payments/components/icons
60K	/tmp/inputs/nextjs-subscription-payments/components/ui
2.0K	/tmp/inputs/nextjs-subscription-payments/fixtures
2.0K	/tmp/inputs/nextjs-subscription-payments/fixtures/stripe-fixtures.json
1.0K	/tmp/inputs/nextjs-subscription-payments/middleware.ts
512	/tmp/inputs/nextjs-subscription-payments/next-env.d.ts
2.5K	/tmp/inputs/nextjs-subscription-payments/package.json
129K	/tmp/inputs/nextjs-subscription-payments/pnpm-lock.yaml
512	/tmp/inputs/nextjs-subscription-payments/postcss.config.js
532K	/tmp/inputs/nextjs-subscription-payments/public
136K	/tmp/inputs/nextjs-subscription-payments/public/architecture_diagram.png
7.5K	/tmp/inputs/nextjs-subscription-payments/public/architecture_diagram.svg
255K	/tmp/inputs/nextjs-subscription-payments/public/demo.png
1.0K	/tmp/inputs/nextjs-subscription-payments/public/favicon.ico
3.0K	/tmp/inputs/nextjs-subscription-payments/public/github.svg
4.0K	/tmp/inputs/nextjs-subscription-payments/public/nextjs.svg
2.0K	/tmp/inputs/nextjs-subscription-payments/public/stripe.svg
5.5K	/tmp/inputs/nextjs-subscription-payments/public/supabase.svg
115K	/tmp/inputs/nextjs-subscription-payments/public/vercel-deploy.png
2.5K	/tmp/inputs/nextjs-subscription-payments/public/vercel.svg
7.5K	/tmp/inputs/nextjs-subscription-payments/schema.sql
1.0K	/tmp/inputs/nextjs-subscription-payments/styles
1.0K	/tmp/inputs/nextjs-subscription-payments/styles/main.css
14K	/tmp/inputs/nextjs-subscription-payments/supabase
6.0K	/tmp/inputs/nextjs-subscription-payments/supabase/config.toml
7.5K	/tmp/inputs/nextjs-subscription-payments/supabase/migrations
0	/tmp/inputs/nextjs-subscription-payments/supabase/seed.sql
1.0K	/tmp/inputs/nextjs-subscription-payments/tailwind.config.js
1.0K	/tmp/inputs/nextjs-subscription-payments/tsconfig.json
20K	/tmp/inputs/nextjs-subscription-payments/types_db.ts
38K	/tmp/inputs/nextjs-subscription-payments/utils
12K	/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers
512	/tmp/inputs/nextjs-subscription-payments/utils/cn.ts
3.5K	/tmp/inputs/nextjs-subscription-payments/utils/helpers.ts
6.0K	/tmp/inputs/nextjs-subscription-payments/utils/stripe
17K	/tmp/inputs/nextjs-subscription-payments/utils/supabase



str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase
output
Here're the files and directories up to 2 levels deep in /tmp/inputs/nextjs-subscription-payments/utils/supabase, excluding hidden items and node_modules:
17K	/tmp/inputs/nextjs-subscription-payments/utils/supabase
10K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
512	/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
2.5K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts
1.5K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
2.0K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts



str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts with line numbers:
1	import { createBrowserClient } from '@supabase/ssr';
2	import { Database } from '@/types_db';
3
4	// Define a function to create a Supabase client for client-side operations
5	export const createClient = () =>
6	  createBrowserClient<Database>(
7	    // Pass Supabase URL and anonymous key from the environment to the client
8	    process.env.NEXT_PUBLIC_SUPABASE_URL!,
9	    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
10	  );
11	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts with line numbers:
1	import { createServerClient, type CookieOptions } from '@supabase/ssr';
2	import { cookies } from 'next/headers';
3	import { Database } from '@/types_db';
4
5	// Define a function to create a Supabase client for server-side operations
6	// The function takes a cookie store created with next/headers cookies as an argument
7	export const createClient = () => {
8	  const cookieStore = cookies();
9
10	  return createServerClient<Database>(
11	    // Pass Supabase URL and anonymous key from the environment to the client
12	    process.env.NEXT_PUBLIC_SUPABASE_URL!,
13	    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
14
15	    // Define a cookies object with methods for interacting with the cookie store and pass it to the client
16	    {
17	      cookies: {
18	        // The get method is used to retrieve a cookie by its name
19	        get(name: string) {
20	          return cookieStore.get(name)?.value;
21	        },
22	        // The set method is used to set a cookie with a given name, value, and options
23	        set(name: string, value: string, options: CookieOptions) {
24	          try {
25	            cookieStore.set({ name, value, ...options });
26	          } catch (error) {
27	            // If the set method is called from a Server Component, an error may occur
28	            // This can be ignored if there is middleware refreshing user sessions
29	          }
30	        },
31	        // The remove method is used to delete a cookie by its name
32	        remove(name: string, options: CookieOptions) {
33	          try {
34	            cookieStore.set({ name, value: '', ...options });
35	          } catch (error) {
36	            // If the remove method is called from a Server Component, an error may occur
37	            // This can be ignored if there is middleware refreshing user sessions
38	          }
39	        }
40	      }
41	    }
42	  );
43	};
44	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts with line numbers:
1	import { toDateTime } from '@/utils/helpers';
2	import { stripe } from '@/utils/stripe/config';
3	import { createClient } from '@supabase/supabase-js';
4	import Stripe from 'stripe';
5	import type { Database, Tables, TablesInsert } from 'types_db';
6
7	type Product = Tables<'products'>;
8	type Price = Tables<'prices'>;
9
10	// Change to control trial period length
11	const TRIAL_PERIOD_DAYS = 0;
12
13	// Note: supabaseAdmin uses the SERVICE_ROLE_KEY which you must only use in a secure server-side context
14	// as it has admin privileges and overwrites RLS policies!
15	const supabaseAdmin = createClient<Database>(
16	  process.env.NEXT_PUBLIC_SUPABASE_URL || '',
17	  process.env.SUPABASE_SERVICE_ROLE_KEY || ''
18	);
19
20	const upsertProductRecord = async (product: Stripe.Product) => {
21	  const productData: Product = {
22	    id: product.id,
23	    active: product.active,
24	    name: product.name,
25	    description: product.description ?? null,
26	    image: product.images?.[0] ?? null,
27	    metadata: product.metadata
28	  };
29
30	  const { error: upsertError } = await supabaseAdmin
31	    .from('products')
32	    .upsert([productData]);
33	  if (upsertError)
34	    throw new Error(`Product insert/update failed: ${upsertError.message}`);
35	  console.log(`Product inserted/updated: ${product.id}`);
36	};
37
38	const upsertPriceRecord = async (
39	  price: Stripe.Price,
40	  retryCount = 0,
41	  maxRetries = 3
42	) => {
43	  const priceData: Price = {
44	    id: price.id,
45	    product_id: typeof price.product === 'string' ? price.product : '',
46	    active: price.active,
47	    currency: price.currency,
48	    type: price.type,
49	    unit_amount: price.unit_amount ?? null,
50	    interval: price.recurring?.interval ?? null,
51	    interval_count: price.recurring?.interval_count ?? null,
52	    trial_period_days: price.recurring?.trial_period_days ?? TRIAL_PERIOD_DAYS
53	  };
54
55	  const { error: upsertError } = await supabaseAdmin
56	    .from('prices')
57	    .upsert([priceData]);
58
59	  if (upsertError?.message.includes('foreign key constraint')) {
60	    if (retryCount < maxRetries) {
61	      console.log(`Retry attempt ${retryCount + 1} for price ID: ${price.id}`);
62	      await new Promise((resolve) => setTimeout(resolve, 2000));
63	      await upsertPriceRecord(price, retryCount + 1, maxRetries);
64	    } else {
65	      throw new Error(
66	        `Price insert/update failed after ${maxRetries} retries: ${upsertError.message}`
67	      );
68	    }
69	  } else if (upsertError) {
70	    throw new Error(`Price insert/update failed: ${upsertError.message}`);
71	  } else {
72	    console.log(`Price inserted/updated: ${price.id}`);
73	  }
74	};
75
76	const deleteProductRecord = async (product: Stripe.Product) => {
77	  const { error: deletionError } = await supabaseAdmin
78	    .from('products')
79	    .delete()
80	    .eq('id', product.id);
81	  if (deletionError)
82	    throw new Error(`Product deletion failed: ${deletionError.message}`);
83	  console.log(`Product deleted: ${product.id}`);
84	};
85
86	const deletePriceRecord = async (price: Stripe.Price) => {
87	  const { error: deletionError } = await supabaseAdmin
88	    .from('prices')
89	    .delete()
90	    .eq('id', price.id);
91	  if (deletionError) throw new Error(`Price deletion failed: ${deletionError.message}`);
92	  console.log(`Price deleted: ${price.id}`);
93	};
94
95	const upsertCustomerToSupabase = async (uuid: string, customerId: string) => {
96	  const { error: upsertError } = await supabaseAdmin
97	    .from('customers')
98	    .upsert([{ id: uuid, stripe_customer_id: customerId }]);
99
100	  if (upsertError)
101	    throw new Error(`Supabase customer record creation failed: ${upsertError.message}`);
102
103	  return customerId;
104	};
105
106	const createCustomerInStripe = async (uuid: string, email: string) => {
107	  const customerData = { metadata: { supabaseUUID: uuid }, email: email };
108	  const newCustomer = await stripe.customers.create(customerData);
109	  if (!newCustomer) throw new Error('Stripe customer creation failed.');
110
111	  return newCustomer.id;
112	};
113
114	const createOrRetrieveCustomer = async ({
115	  email,
116	  uuid
117	}: {
118	  email: string;
119	  uuid: string;
120	}) => {
121	  // Check if the customer already exists in Supabase
122	  const { data: existingSupabaseCustomer, error: queryError } =
123	    await supabaseAdmin
124	      .from('customers')
125	      .select('*')
126	      .eq('id', uuid)
127	      .maybeSingle();
128
129	  if (queryError) {
130	    throw new Error(`Supabase customer lookup failed: ${queryError.message}`);
131	  }
132
133	  // Retrieve the Stripe customer ID using the Supabase customer ID, with email fallback
134	  let stripeCustomerId: string | undefined;
135	  if (existingSupabaseCustomer?.stripe_customer_id) {
136	    const existingStripeCustomer = await stripe.customers.retrieve(
137	      existingSupabaseCustomer.stripe_customer_id
138	    );
139	    stripeCustomerId = existingStripeCustomer.id;
140	  } else {
141	    // If Stripe ID is missing from Supabase, try to retrieve Stripe customer ID by email
142	    const stripeCustomers = await stripe.customers.list({ email: email });
143	    stripeCustomerId =
144	      stripeCustomers.data.length > 0 ? stripeCustomers.data[0].id : undefined;
145	  }
146
147	  // If still no stripeCustomerId, create a new customer in Stripe
148	  const stripeIdToInsert = stripeCustomerId
149	    ? stripeCustomerId
150	    : await createCustomerInStripe(uuid, email);
151	  if (!stripeIdToInsert) throw new Error('Stripe customer creation failed.');
152
153	  if (existingSupabaseCustomer && stripeCustomerId) {
154	    // If Supabase has a record but doesn't match Stripe, update Supabase record
155	    if (existingSupabaseCustomer.stripe_customer_id !== stripeCustomerId) {
156	      const { error: updateError } = await supabaseAdmin
157	        .from('customers')
158	        .update({ stripe_customer_id: stripeCustomerId })
159	        .eq('id', uuid);
160
161	      if (updateError)
162	        throw new Error(
163	          `Supabase customer record update failed: ${updateError.message}`
164	        );
165	      console.warn(
166	        `Supabase customer record mismatched Stripe ID. Supabase record updated.`
167	      );
168	    }
169	    // If Supabase has a record and matches Stripe, return Stripe customer ID
170	    return stripeCustomerId;
171	  } else {
172	    console.warn(
173	      `Supabase customer record was missing. A new record was created.`
174	    );
175
176	    // If Supabase has no record, create a new record and return Stripe customer ID
177	    const upsertedStripeCustomer = await upsertCustomerToSupabase(
178	      uuid,
179	      stripeIdToInsert
180	    );
181	    if (!upsertedStripeCustomer)
182	      throw new Error('Supabase customer record creation failed.');
183
184	    return upsertedStripeCustomer;
185	  }
186	};
187
188	/**
189	 * Copies the billing details from the payment method to the customer object.
190	 */
191	const copyBillingDetailsToCustomer = async (
192	  uuid: string,
193	  payment_method: Stripe.PaymentMethod
194	) => {
195	  //Todo: check this assertion
196	  const customer = payment_method.customer as string;
197	  const { name, phone, address } = payment_method.billing_details;
198	  if (!name || !phone || !address) return;
199	  //@ts-ignore
200	  await stripe.customers.update(customer, { name, phone, address });
201	  const { error: updateError } = await supabaseAdmin
202	    .from('users')
203	    .update({
204	      billing_address: { ...address },
205	      payment_method: { ...payment_method[payment_method.type] }
206	    })
207	    .eq('id', uuid);
208	  if (updateError) throw new Error(`Customer update failed: ${updateError.message}`);
209	};
210
211	const manageSubscriptionStatusChange = async (
212	  subscriptionId: string,
213	  customerId: string,
214	  createAction = false
215	) => {
216	  // Get customer's UUID from mapping table.
217	  const { data: customerData, error: noCustomerError } = await supabaseAdmin
218	    .from('customers')
219	    .select('id')
220	    .eq('stripe_customer_id', customerId)
221	    .single();
222
223	  if (noCustomerError)
224	    throw new Error(`Customer lookup failed: ${noCustomerError.message}`);
225
226	  const { id: uuid } = customerData!;
227
228	  const subscription = await stripe.subscriptions.retrieve(subscriptionId, {
229	    expand: ['default_payment_method']
230	  });
231	  // Upsert the latest status of the subscription object.
232	  const subscriptionData: TablesInsert<'subscriptions'> = {
233	    id: subscription.id,
234	    user_id: uuid,
235	    metadata: subscription.metadata,
236	    status: subscription.status,
237	    price_id: subscription.items.data[0].price.id,
238	    //TODO check quantity on subscription
239	    // @ts-ignore
240	    quantity: subscription.quantity,
241	    cancel_at_period_end: subscription.cancel_at_period_end,
242	    cancel_at: subscription.cancel_at
243	      ? toDateTime(subscription.cancel_at).toISOString()
244	      : null,
245	    canceled_at: subscription.canceled_at
246	      ? toDateTime(subscription.canceled_at).toISOString()
247	      : null,
248	    current_period_start: toDateTime(
249	      subscription.current_period_start
250	    ).toISOString(),
251	    current_period_end: toDateTime(
252	      subscription.current_period_end
253	    ).toISOString(),
254	    created: toDateTime(subscription.created).toISOString(),
255	    ended_at: subscription.ended_at
256	      ? toDateTime(subscription.ended_at).toISOString()
257	      : null,
258	    trial_start: subscription.trial_start
259	      ? toDateTime(subscription.trial_start).toISOString()
260	      : null,
261	    trial_end: subscription.trial_end
262	      ? toDateTime(subscription.trial_end).toISOString()
263	      : null
264	  };
265
266	  const { error: upsertError } = await supabaseAdmin
267	    .from('subscriptions')
268	    .upsert([subscriptionData]);
269	  if (upsertError)
270	    throw new Error(`Subscription insert/update failed: ${upsertError.message}`);
271	  console.log(
272	    `Inserted/updated subscription [${subscription.id}] for user [${uuid}]`
273	  );
274
275	  // For a new subscription copy the billing details to the customer object.
276	  // NOTE: This is a costly operation and should happen at the very end.
277	  if (createAction && subscription.default_payment_method && uuid)
278	    //@ts-ignore
279	    await copyBillingDetailsToCustomer(
280	      uuid,
281	      subscription.default_payment_method as Stripe.PaymentMethod
282	    );
283	};
284
285	export {
286	  upsertProductRecord,
287	  upsertPriceRecord,
288	  deleteProductRecord,
289	  deletePriceRecord,
290	  createOrRetrieveCustomer,
291	  manageSubscriptionStatusChange
292	};
293	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts with line numbers:
1	import Stripe from 'stripe';
2
3	export const stripe = new Stripe(
4	  process.env.STRIPE_SECRET_KEY_LIVE ?? process.env.STRIPE_SECRET_KEY ?? '',
5	  {
6	    // https://github.com/stripe/stripe-node#configuration
7	    // https://stripe.com/docs/api/versioning
8	    // @ts-ignore
9	    apiVersion: null,
10	    // Register this as an official Stripe plugin.
11	    // https://stripe.com/docs/building-plugins#setappinfo
12	    appInfo: {
13	      name: 'Next.js Subscription Starter',
14	      version: '0.0.0',
15	      url: 'https://github.com/vercel/nextjs-subscription-payments'
16	    }
17	  }
18	);
19	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts with line numbers:
1	'use server';
2
3	import Stripe from 'stripe';
4	import { stripe } from '@/utils/stripe/config';
5	import { createClient } from '@/utils/supabase/server';
6	import { createOrRetrieveCustomer } from '@/utils/supabase/admin';
7	import {
8	  getURL,
9	  getErrorRedirect,
10	  calculateTrialEndUnixTimestamp
11	} from '@/utils/helpers';
12	import { Tables } from '@/types_db';
13
14	type Price = Tables<'prices'>;
15
16	type CheckoutResponse = {
17	  errorRedirect?: string;
18	  sessionId?: string;
19	};
20
21	export async function checkoutWithStripe(
22	  price: Price,
23	  redirectPath: string = '/account'
24	): Promise<CheckoutResponse> {
25	  try {
26	    // Get the user from Supabase auth
27	    const supabase = createClient();
28	    const {
29	      error,
30	      data: { user }
31	    } = await supabase.auth.getUser();
32
33	    if (error || !user) {
34	      console.error(error);
35	      throw new Error('Could not get user session.');
36	    }
37
38	    // Retrieve or create the customer in Stripe
39	    let customer: string;
40	    try {
41	      customer = await createOrRetrieveCustomer({
42	        uuid: user?.id || '',
43	        email: user?.email || ''
44	      });
45	    } catch (err) {
46	      console.error(err);
47	      throw new Error('Unable to access customer record.');
48	    }
49
50	    let params: Stripe.Checkout.SessionCreateParams = {
51	      allow_promotion_codes: true,
52	      billing_address_collection: 'required',
53	      customer,
54	      customer_update: {
55	        address: 'auto'
56	      },
57	      line_items: [
58	        {
59	          price: price.id,
60	          quantity: 1
61	        }
62	      ],
63	      cancel_url: getURL(),
64	      success_url: getURL(redirectPath)
65	    };
66
67	    console.log(
68	      'Trial end:',
69	      calculateTrialEndUnixTimestamp(price.trial_period_days)
70	    );
71	    if (price.type === 'recurring') {
72	      params = {
73	        ...params,
74	        mode: 'subscription',
75	        subscription_data: {
76	          trial_end: calculateTrialEndUnixTimestamp(price.trial_period_days)
77	        }
78	      };
79	    } else if (price.type === 'one_time') {
80	      params = {
81	        ...params,
82	        mode: 'payment'
83	      };
84	    }
85
86	    // Create a checkout session in Stripe
87	    let session;
88	    try {
89	      session = await stripe.checkout.sessions.create(params);
90	    } catch (err) {
91	      console.error(err);
92	      throw new Error('Unable to create checkout session.');
93	    }
94
95	    // Instead of returning a Response, just return the data or error.
96	    if (session) {
97	      return { sessionId: session.id };
98	    } else {
99	      throw new Error('Unable to create checkout session.');
100	    }
101	  } catch (error) {
102	    if (error instanceof Error) {
103	      return {
104	        errorRedirect: getErrorRedirect(
105	          redirectPath,
106	          error.message,
107	          'Please try again later or contact a system administrator.'
108	        )
109	      };
110	    } else {
111	      return {
112	        errorRedirect: getErrorRedirect(
113	          redirectPath,
114	          'An unknown error occurred.',
115	          'Please try again later or contact a system administrator.'
116	        )
117	      };
118	    }
119	  }
120	}
121
122	export async function createStripePortal(currentPath: string) {
123	  try {
124	    const supabase = createClient();
125	    const {
126	      error,
127	      data: { user }
128	    } = await supabase.auth.getUser();
129
130	    if (!user) {
131	      if (error) {
132	        console.error(error);
133	      }
134	      throw new Error('Could not get user session.');
135	    }
136
137	    let customer;
138	    try {
139	      customer = await createOrRetrieveCustomer({
140	        uuid: user.id || '',
141	        email: user.email || ''
142	      });
143	    } catch (err) {
144	      console.error(err);
145	      throw new Error('Unable to access customer record.');
146	    }
147
148	    if (!customer) {
149	      throw new Error('Could not get customer.');
150	    }
151
152	    try {
153	      const { url } = await stripe.billingPortal.sessions.create({
154	        customer,
155	        return_url: getURL('/account')
156	      });
157	      if (!url) {
158	        throw new Error('Could not create billing portal');
159	      }
160	      return url;
161	    } catch (err) {
162	      console.error(err);
163	      throw new Error('Could not create billing portal');
164	    }
165	  } catch (error) {
166	    if (error instanceof Error) {
167	      console.error(error);
168	      return getErrorRedirect(
169	        currentPath,
170	        error.message,
171	        'Please try again later or contact a system administrator.'
172	      );
173	    } else {
174	      return getErrorRedirect(
175	        currentPath,
176	        'An unknown error occurred.',
177	        'Please try again later or contact a system administrator.'
178	      );
179	    }
180	  }
181	}
182	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts with line numbers:
1	import { SupabaseClient } from '@supabase/supabase-js';
2	import { cache } from 'react';
3
4	export const getUser = cache(async (supabase: SupabaseClient) => {
5	  const {
6	    data: { user }
7	  } = await supabase.auth.getUser();
8	  return user;
9	});
10
11	export const getSubscription = cache(async (supabase: SupabaseClient) => {
12	  const { data: subscription, error } = await supabase
13	    .from('subscriptions')
14	    .select('*, prices(*, products(*))')
15	    .in('status', ['trialing', 'active'])
16	    .maybeSingle();
17
18	  return subscription;
19	});
20
21	export const getProducts = cache(async (supabase: SupabaseClient) => {
22	  const { data: products, error } = await supabase
23	    .from('products')
24	    .select('*, prices(*)')
25	    .eq('active', true)
26	    .eq('prices.active', true)
27	    .order('metadata->index')
28	    .order('unit_amount', { referencedTable: 'prices' });
29
30	  return products;
31	});
32
33	export const getUserDetails = cache(async (supabase: SupabaseClient) => {
34	  const { data: userDetails } = await supabase
35	    .from('users')
36	    .select('*')
37	    .single();
38	  return userDetails;
39	});
40	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/app/page.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/app/page.tsx with line numbers:
1	import Pricing from '@/components/ui/Pricing/Pricing';
2	import { createClient } from '@/utils/supabase/server';
3	import {
4	  getProducts,
5	  getSubscription,
6	  getUser
7	} from '@/utils/supabase/queries';
8
9	export default async function PricingPage() {
10	  const supabase = createClient();
11	  const [user, products, subscription] = await Promise.all([
12	    getUser(supabase),
13	    getProducts(supabase),
14	    getSubscription(supabase)
15	  ]);
16
17	  return (
18	    <Pricing
19	      user={user}
20	      products={products ?? []}
21	      subscription={subscription}
22	    />
23	  );
24	}
25	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx with line numbers:
1	'use client';
2
3	import Button from '@/components/ui/Button';
4	import LogoCloud from '@/components/ui/LogoCloud';
5	import type { Tables } from '@/types_db';
6	import { getStripe } from '@/utils/stripe/client';
7	import { checkoutWithStripe } from '@/utils/stripe/server';
8	import { getErrorRedirect } from '@/utils/helpers';
9	import { User } from '@supabase/supabase-js';
10	import cn from 'classnames';
11	import { useRouter, usePathname } from 'next/navigation';
12	import { useState } from 'react';
13
14	type Subscription = Tables<'subscriptions'>;
15	type Product = Tables<'products'>;
16	type Price = Tables<'prices'>;
17	interface ProductWithPrices extends Product {
18	  prices: Price[];
19	}
20	interface PriceWithProduct extends Price {
21	  products: Product | null;
22	}
23	interface SubscriptionWithProduct extends Subscription {
24	  prices: PriceWithProduct | null;
25	}
26
27	interface Props {
28	  user: User | null | undefined;
29	  products: ProductWithPrices[];
30	  subscription: SubscriptionWithProduct | null;
31	}
32
33	type BillingInterval = 'lifetime' | 'year' | 'month';
34
35	export default function Pricing({ user, products, subscription }: Props) {
36	  const intervals = Array.from(
37	    new Set(
38	      products.flatMap((product) =>
39	        product?.prices?.map((price) => price?.interval)
40	      )
41	    )
42	  );
43	  const router = useRouter();
44	  const [billingInterval, setBillingInterval] =
45	    useState<BillingInterval>('month');
46	  const [priceIdLoading, setPriceIdLoading] = useState<string>();
47	  const currentPath = usePathname();
48
49	  const handleStripeCheckout = async (price: Price) => {
50	    setPriceIdLoading(price.id);
51
52	    if (!user) {
53	      setPriceIdLoading(undefined);
54	      return router.push('/signin/signup');
55	    }
56
57	    const { errorRedirect, sessionId } = await checkoutWithStripe(
58	      price,
59	      currentPath
60	    );
61
62	    if (errorRedirect) {
63	      setPriceIdLoading(undefined);
64	      return router.push(errorRedirect);
65	    }
66
67	    if (!sessionId) {
68	      setPriceIdLoading(undefined);
69	      return router.push(
70	        getErrorRedirect(
71	          currentPath,
72	          'An unknown error occurred.',
73	          'Please try again later or contact a system administrator.'
74	        )
75	      );
76	    }
77
78	    const stripe = await getStripe();
79	    stripe?.redirectToCheckout({ sessionId });
80
81	    setPriceIdLoading(undefined);
82	  };
83
84	  if (!products.length) {
85	    return (
86	      <section className="bg-black">
87	        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
88	          <div className="sm:flex sm:flex-col sm:align-center"></div>
89	          <p className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
90	            No subscription pricing plans found. Create them in your{' '}
91	            <a
92	              className="text-pink-500 underline"
93	              href="https://dashboard.stripe.com/products"
94	              rel="noopener noreferrer"
95	              target="_blank"
96	            >
97	              Stripe Dashboard
98	            </a>
99	            .
100	          </p>
101	        </div>
102	        <LogoCloud />
103	      </section>
104	    );
105	  } else {
106	    return (
107	      <section className="bg-black">
108	        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
109	          <div className="sm:flex sm:flex-col sm:align-center">
110	            <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
111	              Pricing Plans
112	            </h1>
113	            <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
114	              Start building for free, then add a site plan to go live. Account
115	              plans unlock additional features.
116	            </p>
117	            <div className="relative self-center mt-6 bg-zinc-900 rounded-lg p-0.5 flex sm:mt-8 border border-zinc-800">
118	              {intervals.includes('month') && (
119	                <button
120	                  onClick={() => setBillingInterval('month')}
121	                  type="button"
122	                  className={`${
123	                    billingInterval === 'month'
124	                      ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
125	                      : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
126	                  } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
127	                >
128	                  Monthly billing
129	                </button>
130	              )}
131	              {intervals.includes('year') && (
132	                <button
133	                  onClick={() => setBillingInterval('year')}
134	                  type="button"
135	                  className={`${
136	                    billingInterval === 'year'
137	                      ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
138	                      : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
139	                  } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
140	                >
141	                  Yearly billing
142	                </button>
143	              )}
144	            </div>
145	          </div>
146	          <div className="mt-12 space-y-0 sm:mt-16 flex flex-wrap justify-center gap-6 lg:max-w-4xl lg:mx-auto xl:max-w-none xl:mx-0">
147	            {products.map((product) => {
148	              const price = product?.prices?.find(
149	                (price) => price.interval === billingInterval
150	              );
151	              if (!price) return null;
152	              const priceString = new Intl.NumberFormat('en-US', {
153	                style: 'currency',
154	                currency: price.currency!,
155	                minimumFractionDigits: 0
156	              }).format((price?.unit_amount || 0) / 100);
157	              return (
158	                <div
159	                  key={product.id}
160	                  className={cn(
161	                    'flex flex-col rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900',
162	                    {
163	                      'border border-pink-500': subscription
164	                        ? product.name === subscription?.prices?.products?.name
165	                        : product.name === 'Freelancer'
166	                    },
167	                    'flex-1', // This makes the flex item grow to fill the space
168	                    'basis-1/3', // Assuming you want each card to take up roughly a third of the container's width
169	                    'max-w-xs' // Sets a maximum width to the cards to prevent them from getting too large
170	                  )}
171	                >
172	                  <div className="p-6">
173	                    <h2 className="text-2xl font-semibold leading-6 text-white">
174	                      {product.name}
175	                    </h2>
176	                    <p className="mt-4 text-zinc-300">{product.description}</p>
177	                    <p className="mt-8">
178	                      <span className="text-5xl font-extrabold white">
179	                        {priceString}
180	                      </span>
181	                      <span className="text-base font-medium text-zinc-100">
182	                        /{billingInterval}
183	                      </span>
184	                    </p>
185	                    <Button
186	                      variant="slim"
187	                      type="button"
188	                      loading={priceIdLoading === price.id}
189	                      onClick={() => handleStripeCheckout(price)}
190	                      className="block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900"
191	                    >
192	                      {subscription ? 'Manage' : 'Subscribe'}
193	                    </Button>
194	                  </div>
195	                </div>
196	              );
197	            })}
198	          </div>
199	          <LogoCloud />
200	        </div>
201	      </section>
202	    );
203	  }
204	}
205	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx with line numbers:
1	'use client';
2
3	import Button from '@/components/ui/Button';
4	import { useRouter, usePathname } from 'next/navigation';
5	import { useState } from 'react';
6	import { createStripePortal } from '@/utils/stripe/server';
7	import Link from 'next/link';
8	import Card from '@/components/ui/Card';
9	import { Tables } from '@/types_db';
10
11	type Subscription = Tables<'subscriptions'>;
12	type Price = Tables<'prices'>;
13	type Product = Tables<'products'>;
14
15	type SubscriptionWithPriceAndProduct = Subscription & {
16	  prices:
17	    | (Price & {
18	        products: Product | null;
19	      })
20	    | null;
21	};
22
23	interface Props {
24	  subscription: SubscriptionWithPriceAndProduct | null;
25	}
26
27	export default function CustomerPortalForm({ subscription }: Props) {
28	  const router = useRouter();
29	  const currentPath = usePathname();
30	  const [isSubmitting, setIsSubmitting] = useState(false);
31
32	  const subscriptionPrice =
33	    subscription &&
34	    new Intl.NumberFormat('en-US', {
35	      style: 'currency',
36	      currency: subscription?.prices?.currency!,
37	      minimumFractionDigits: 0
38	    }).format((subscription?.prices?.unit_amount || 0) / 100);
39
40	  const handleStripePortalRequest = async () => {
41	    setIsSubmitting(true);
42	    const redirectUrl = await createStripePortal(currentPath);
43	    setIsSubmitting(false);
44	    return router.push(redirectUrl);
45	  };
46
47	  return (
48	    <Card
49	      title="Your Plan"
50	      description={
51	        subscription
52	          ? `You are currently on the ${subscription?.prices?.products?.name} plan.`
53	          : 'You are not currently subscribed to any plan.'
54	      }
55	      footer={
56	        <div className="flex flex-col items-start justify-between sm:flex-row sm:items-center">
57	          <p className="pb-4 sm:pb-0">Manage your subscription on Stripe.</p>
58	          <Button
59	            variant="slim"
60	            onClick={handleStripePortalRequest}
61	            loading={isSubmitting}
62	          >
63	            Open customer portal
64	          </Button>
65	        </div>
66	      }
67	    >
68	      <div className="mt-8 mb-4 text-xl font-semibold">
69	        {subscription ? (
70	          `${subscriptionPrice}/${subscription?.prices?.interval}`
71	        ) : (
72	          <Link href="/">Choose your plan</Link>
73	        )}
74	      </div>
75	    </Card>
76	  );
77	}
78	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts with line numbers:
1	'use server';
2
3	import { createClient } from '@/utils/supabase/server';
4	import { cookies } from 'next/headers';
5	import { redirect } from 'next/navigation';
6	import { getURL, getErrorRedirect, getStatusRedirect } from 'utils/helpers';
7	import { getAuthTypes } from 'utils/auth-helpers/settings';
8
9	function isValidEmail(email: string) {
10	  var regex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
11	  return regex.test(email);
12	}
13
14	export async function redirectToPath(path: string) {
15	  return redirect(path);
16	}
17
18	export async function SignOut(formData: FormData) {
19	  const pathName = String(formData.get('pathName')).trim();
20
21	  const supabase = createClient();
22	  const { error } = await supabase.auth.signOut();
23
24	  if (error) {
25	    return getErrorRedirect(
26	      pathName,
27	      'Hmm... Something went wrong.',
28	      'You could not be signed out.'
29	    );
30	  }
31
32	  return '/signin';
33	}
34
35	export async function signInWithEmail(formData: FormData) {
36	  const cookieStore = cookies();
37	  const callbackURL = getURL('/auth/callback');
38
39	  const email = String(formData.get('email')).trim();
40	  let redirectPath: string;
41
42	  if (!isValidEmail(email)) {
43	    redirectPath = getErrorRedirect(
44	      '/signin/email_signin',
45	      'Invalid email address.',
46	      'Please try again.'
47	    );
48	  }
49
50	  const supabase = createClient();
51	  let options = {
52	    emailRedirectTo: callbackURL,
53	    shouldCreateUser: true
54	  };
55
56	  // If allowPassword is false, do not create a new user
57	  const { allowPassword } = getAuthTypes();
58	  if (allowPassword) options.shouldCreateUser = false;
59	  const { data, error } = await supabase.auth.signInWithOtp({
60	    email,
61	    options: options
62	  });
63
64	  if (error) {
65	    redirectPath = getErrorRedirect(
66	      '/signin/email_signin',
67	      'You could not be signed in.',
68	      error.message
69	    );
70	  } else if (data) {
71	    cookieStore.set('preferredSignInView', 'email_signin', { path: '/' });
72	    redirectPath = getStatusRedirect(
73	      '/signin/email_signin',
74	      'Success!',
75	      'Please check your email for a magic link. You may now close this tab.',
76	      true
77	    );
78	  } else {
79	    redirectPath = getErrorRedirect(
80	      '/signin/email_signin',
81	      'Hmm... Something went wrong.',
82	      'You could not be signed in.'
83	    );
84	  }
85
86	  return redirectPath;
87	}
88
89	export async function requestPasswordUpdate(formData: FormData) {
90	  const callbackURL = getURL('/auth/reset_password');
91
92	  // Get form data
93	  const email = String(formData.get('email')).trim();
94	  let redirectPath: string;
95
96	  if (!isValidEmail(email)) {
97	    redirectPath = getErrorRedirect(
98	      '/signin/forgot_password',
99	      'Invalid email address.',
100	      'Please try again.'
101	    );
102	  }
103
104	  const supabase = createClient();
105
106	  const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
107	    redirectTo: callbackURL
108	  });
109
110	  if (error) {
111	    redirectPath = getErrorRedirect(
112	      '/signin/forgot_password',
113	      error.message,
114	      'Please try again.'
115	    );
116	  } else if (data) {
117	    redirectPath = getStatusRedirect(
118	      '/signin/forgot_password',
119	      'Success!',
120	      'Please check your email for a password reset link. You may now close this tab.',
121	      true
122	    );
123	  } else {
124	    redirectPath = getErrorRedirect(
125	      '/signin/forgot_password',
126	      'Hmm... Something went wrong.',
127	      'Password reset email could not be sent.'
128	    );
129	  }
130
131	  return redirectPath;
132	}
133
134	export async function signInWithPassword(formData: FormData) {
135	  const cookieStore = cookies();
136	  const email = String(formData.get('email')).trim();
137	  const password = String(formData.get('password')).trim();
138	  let redirectPath: string;
139
140	  const supabase = createClient();
141	  const { error, data } = await supabase.auth.signInWithPassword({
142	    email,
143	    password
144	  });
145
146	  if (error) {
147	    redirectPath = getErrorRedirect(
148	      '/signin/password_signin',
149	      'Sign in failed.',
150	      error.message
151	    );
152	  } else if (data.user) {
153	    cookieStore.set('preferredSignInView', 'password_signin', { path: '/' });
154	    redirectPath = getStatusRedirect('/', 'Success!', 'You are now signed in.');
155	  } else {
156	    redirectPath = getErrorRedirect(
157	      '/signin/password_signin',
158	      'Hmm... Something went wrong.',
159	      'You could not be signed in.'
160	    );
161	  }
162
163	  return redirectPath;
164	}
165
166	export async function signUp(formData: FormData) {
167	  const callbackURL = getURL('/auth/callback');
168
169	  const email = String(formData.get('email')).trim();
170	  const password = String(formData.get('password')).trim();
171	  let redirectPath: string;
172
173	  if (!isValidEmail(email)) {
174	    redirectPath = getErrorRedirect(
175	      '/signin/signup',
176	      'Invalid email address.',
177	      'Please try again.'
178	    );
179	  }
180
181	  const supabase = createClient();
182	  const { error, data } = await supabase.auth.signUp({
183	    email,
184	    password,
185	    options: {
186	      emailRedirectTo: callbackURL
187	    }
188	  });
189
190	  if (error) {
191	    redirectPath = getErrorRedirect(
192	      '/signin/signup',
193	      'Sign up failed.',
194	      error.message
195	    );
196	  } else if (data.session) {
197	    redirectPath = getStatusRedirect('/', 'Success!', 'You are now signed in.');
198	  } else if (
199	    data.user &&
200	    data.user.identities &&
201	    data.user.identities.length == 0
202	  ) {
203	    redirectPath = getErrorRedirect(
204	      '/signin/signup',
205	      'Sign up failed.',
206	      'There is already an account associated with this email address. Try resetting your password.'
207	    );
208	  } else if (data.user) {
209	    redirectPath = getStatusRedirect(
210	      '/',
211	      'Success!',
212	      'Please check your email for a confirmation link. You may now close this tab.'
213	    );
214	  } else {
215	    redirectPath = getErrorRedirect(
216	      '/signin/signup',
217	      'Hmm... Something went wrong.',
218	      'You could not be signed up.'
219	    );
220	  }
221
222	  return redirectPath;
223	}
224
225	export async function updatePassword(formData: FormData) {
226	  const password = String(formData.get('password')).trim();
227	  const passwordConfirm = String(formData.get('passwordConfirm')).trim();
228	  let redirectPath: string;
229
230	  // Check that the password and confirmation match
231	  if (password !== passwordConfirm) {
232	    redirectPath = getErrorRedirect(
233	      '/signin/update_password',
234	      'Your password could not be updated.',
235	      'Passwords do not match.'
236	    );
237	  }
238
239	  const supabase = createClient();
240	  const { error, data } = await supabase.auth.updateUser({
241	    password
242	  });
243
244	  if (error) {
245	    redirectPath = getErrorRedirect(
246	      '/signin/update_password',
247	      'Your password could not be updated.',
248	      error.message
249	    );
250	  } else if (data.user) {
251	    redirectPath = getStatusRedirect(
252	      '/',
253	      'Success!',
254	      'Your password has been updated.'
255	    );
256	  } else {
257	    redirectPath = getErrorRedirect(
258	      '/signin/update_password',
259	      'Hmm... Something went wrong.',
260	      'Your password could not be updated.'
261	    );
262	  }
263
264	  return redirectPath;
265	}
266
267	export async function updateEmail(formData: FormData) {
268	  // Get form data
269	  const newEmail = String(formData.get('newEmail')).trim();
270
271	  // Check that the email is valid
272	  if (!isValidEmail(newEmail)) {
273	    return getErrorRedirect(
274	      '/account',
275	      'Your email could not be updated.',
276	      'Invalid email address.'
277	    );
278	  }
279
280	  const supabase = createClient();
281
282	  const callbackUrl = getURL(
283	    getStatusRedirect('/account', 'Success!', `Your email has been updated.`)
284	  );
285
286	  const { error } = await supabase.auth.updateUser(
287	    { email: newEmail },
288	    {
289	      emailRedirectTo: callbackUrl
290	    }
291	  );
292
293	  if (error) {
294	    return getErrorRedirect(
295	      '/account',
296	      'Your email could not be updated.',
297	      error.message
298	    );
299	  } else {
300	    return getStatusRedirect(
301	      '/account',
302	      'Confirmation emails sent.',
303	      `You will need to confirm the update by clicking the links sent to both the old and new email addresses.`
304	    );
305	  }
306	}
307
308	export async function updateName(formData: FormData) {
309	  // Get form data
310	  const fullName = String(formData.get('fullName')).trim();
311
312	  const supabase = createClient();
313	  const { error, data } = await supabase.auth.updateUser({
314	    data: { full_name: fullName }
315	  });
316
317	  if (error) {
318	    return getErrorRedirect(
319	      '/account',
320	      'Your name could not be updated.',
321	      error.message
322	    );
323	  } else if (data.user) {
324	    return getStatusRedirect(
325	      '/account',
326	      'Success!',
327	      'Your name has been updated.'
328	    );
329	  } else {
330	    return getErrorRedirect(
331	      '/account',
332	      'Hmm... Something went wrong.',
333	      'Your name could not be updated.'
334	    );
335	  }
336	}
337	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/client.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/client.ts with line numbers:
1	'use client';
2
3	import { createClient } from '@/utils/supabase/client';
4	import { type Provider } from '@supabase/supabase-js';
5	import { getURL } from '@/utils/helpers';
6	import { redirectToPath } from './server';
7	import { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime';
8
9	export async function handleRequest(
10	  e: React.FormEvent<HTMLFormElement>,
11	  requestFunc: (formData: FormData) => Promise<string>,
12	  router: AppRouterInstance | null = null
13	): Promise<boolean | void> {
14	  // Prevent default form submission refresh
15	  e.preventDefault();
16
17	  const formData = new FormData(e.currentTarget);
18	  const redirectUrl: string = await requestFunc(formData);
19
20	  if (router) {
21	    // If client-side router is provided, use it to redirect
22	    return router.push(redirectUrl);
23	  } else {
24	    // Otherwise, redirect server-side
25	    return await redirectToPath(redirectUrl);
26	  }
27	}
28
29	export async function signInWithOAuth(e: React.FormEvent<HTMLFormElement>) {
30	  // Prevent default form submission refresh
31	  e.preventDefault();
32	  const formData = new FormData(e.currentTarget);
33	  const provider = String(formData.get('provider')).trim() as Provider;
34
35	  // Create client-side supabase client and call signInWithOAuth
36	  const supabase = createClient();
37	  const redirectURL = getURL('/auth/callback');
38	  await supabase.auth.signInWithOAuth({
39	    provider: provider,
40	    options: {
41	      redirectTo: redirectURL
42	    }
43	  });
44	}
45	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navlinks.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navlinks.tsx with line numbers:
1	'use client';
2
3	import Link from 'next/link';
4	import { SignOut } from '@/utils/auth-helpers/server';
5	import { handleRequest } from '@/utils/auth-helpers/client';
6	import Logo from '@/components/icons/Logo';
7	import { usePathname, useRouter } from 'next/navigation';
8	import { getRedirectMethod } from '@/utils/auth-helpers/settings';
9	import s from './Navbar.module.css';
10
11	interface NavlinksProps {
12	  user?: any;
13	}
14
15	export default function Navlinks({ user }: NavlinksProps) {
16	  const router = getRedirectMethod() === 'client' ? useRouter() : null;
17
18	  return (
19	    <div className="relative flex flex-row justify-between py-4 align-center md:py-6">
20	      <div className="flex items-center flex-1">
21	        <Link href="/" className={s.logo} aria-label="Logo">
22	          <Logo />
23	        </Link>
24	        <nav className="ml-6 space-x-2 lg:block">
25	          <Link href="/" className={s.link}>
26	            Pricing
27	          </Link>
28	          {user && (
29	            <Link href="/account" className={s.link}>
30	              Account
31	            </Link>
32	          )}
33	        </nav>
34	      </div>
35	      <div className="flex justify-end space-x-8">
36	        {user ? (
37	          <form onSubmit={(e) => handleRequest(e, SignOut, router)}>
38	            <input type="hidden" name="pathName" value={usePathname()} />
39	            <button type="submit" className={s.link}>
40	              Sign out
41	            </button>
42	          </form>
43	        ) : (
44	          <Link href="/signin" className={s.link}>
45	            Sign In
46	          </Link>
47	        )}
48	      </div>
49	    </div>
50	  );
51	}
52	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/app/account/page.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/app/account/page.tsx with line numbers:
1	import CustomerPortalForm from '@/components/ui/AccountForms/CustomerPortalForm';
2	import EmailForm from '@/components/ui/AccountForms/EmailForm';
3	import NameForm from '@/components/ui/AccountForms/NameForm';
4	import { redirect } from 'next/navigation';
5	import { createClient } from '@/utils/supabase/server';
6	import {
7	  getUserDetails,
8	  getSubscription,
9	  getUser
10	} from '@/utils/supabase/queries';
11
12	export default async function Account() {
13	  const supabase = createClient();
14	  const [user, userDetails, subscription] = await Promise.all([
15	    getUser(supabase),
16	    getUserDetails(supabase),
17	    getSubscription(supabase)
18	  ]);
19
20	  if (!user) {
21	    return redirect('/signin');
22	  }
23
24	  return (
25	    <section className="mb-32 bg-black">
26	      <div className="max-w-6xl px-4 py-8 mx-auto sm:px-6 sm:pt-24 lg:px-8">
27	        <div className="sm:align-center sm:flex sm:flex-col">
28	          <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
29	            Account
30	          </h1>
31	          <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
32	            We partnered with Stripe for a simplified billing.
33	          </p>
34	        </div>
35	      </div>
36	      <div className="p-4">
37	        <CustomerPortalForm subscription={subscription} />
38	        <NameForm userName={userDetails?.full_name ?? ''} />
39	        <EmailForm userEmail={user.email} />
40	      </div>
41	    </section>
42	  );
43	}
44	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts with line numbers:
1	import { loadStripe, Stripe } from '@stripe/stripe-js';
2
3	let stripePromise: Promise<Stripe | null>;
4
5	export const getStripe = () => {
6	  if (!stripePromise) {
7	    stripePromise = loadStripe(
8	      process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY_LIVE ??
9	        process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY ??
10	        ''
11	    );
12	  }
13
14	  return stripePromise;
15	};
16	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/app/layout.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/app/layout.tsx with line numbers:
1	import { Metadata } from 'next';
2	import Footer from '@/components/ui/Footer';
3	import Navbar from '@/components/ui/Navbar';
4	import { Toaster } from '@/components/ui/Toasts/toaster';
5	import { PropsWithChildren, Suspense } from 'react';
6	import { getURL } from '@/utils/helpers';
7	import 'styles/main.css';
8
9	const title = 'Next.js Subscription Starter';
10	const description = 'Brought to you by Vercel, Stripe, and Supabase.';
11
12	export const metadata: Metadata = {
13	  metadataBase: new URL(getURL()),
14	  title: title,
15	  description: description,
16	  openGraph: {
17	    title: title,
18	    description: description
19	  }
20	};
21
22	export default async function RootLayout({ children }: PropsWithChildren) {
23	  return (
24	    <html lang="en">
25	      <body className="bg-black">
26	        <Navbar />
27	        <main
28	          id="skip"
29	          className="min-h-[calc(100dvh-4rem)] md:min-h[calc(100dvh-5rem)]"
30	        >
31	          {children}
32	        </main>
33	        <Footer />
34	        <Suspense>
35	          <Toaster />
36	        </Suspense>
37	      </body>
38	    </html>
39	  );
40	}
41	

Now I have a good understanding of the codebase. Let me summarize the dependency injection patterns used.

This codebase uses several dependency injection patterns, though they're lightweight and idiomatic to the Next.js/React ecosystem rather than using a formal DI container like you'd see in enterprise Java or .NET applications.

**1. Factory Function Pattern**

The most prominent pattern is the factory function approach for creating service clients. You can see this in `utils/supabase/client.ts` and `utils/supabase/server.ts` where `createClient()` functions act as factories that construct and return configured Supabase client instances. The server version injects the cookie store dependency internally by calling `cookies()` from Next.js, while the client version reads from environment variables. This lets consumers simply call `createClient()` without worrying about configuration details.

**2. Module-Level Singleton Pattern**

For services that should only be instantiated once, the codebase uses module-level singletons. In `utils/stripe/config.ts`, a single `stripe` instance is created and exported. The same pattern appears in `utils/stripe/client.ts` with `getStripe()`, which uses lazy initialization—it only creates the Stripe instance on first call and returns the cached promise on subsequent calls. The admin Supabase client in `utils/supabase/admin.ts` is also a module-level singleton created with the service role key.

**3. Parameter Injection (Manual DI)**

The query functions in `utils/supabase/queries.ts` demonstrate explicit dependency injection through function parameters. Functions like `getUser(supabase)`, `getProducts(supabase)`, and `getSubscription(supabase)` all accept a `SupabaseClient` as a parameter rather than creating their own. This makes them flexible and testable—the caller controls which client instance gets used, and you could easily pass a mock client in tests.

**4. Props-Based Injection (React Pattern)**

Components receive their dependencies through props rather than fetching data themselves. For example, the `Pricing` component receives `user`, `products`, and `subscription` as props. The parent page (`app/page.tsx`) handles creating the Supabase client and fetching data, then passes results down. This separates data fetching concerns from presentation and makes components more reusable and testable.

**5. Environment-Based Configuration Injection**

Throughout the codebase, configuration is injected via environment variables. The Stripe and Supabase clients all read their API keys and URLs from `process.env`. This allows the same code to work across different environments (development, staging, production) without code changes.

The overall approach is pragmatic—no formal DI framework, but clear separation of concerns. Services are created through factories, dependencies flow through function parameters or React props, and configuration comes from the environment. This keeps the code simple while still achieving the testability and flexibility benefits that dependency injection provides. 


———MODEL A RESPONES ended!!!!——————

———MODEL B RESPONES IS BELOW!!!!——————
3.here is model B’s response: 
bash
command
find /tmp/inputs/nextjs-subscription-payments -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) | head -50
output
/tmp/inputs/nextjs-subscription-payments/types_db.ts
/tmp/inputs/nextjs-subscription-payments/middleware.ts
/tmp/inputs/nextjs-subscription-payments/tailwind.config.js
/tmp/inputs/nextjs-subscription-payments/next-env.d.ts
/tmp/inputs/nextjs-subscription-payments/postcss.config.js
/tmp/inputs/nextjs-subscription-payments/components/icons/GitHub.tsx
/tmp/inputs/nextjs-subscription-payments/components/icons/Logo.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LogoCloud/LogoCloud.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LogoCloud/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Button/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Button/Button.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LoadingDots/LoadingDots.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/LoadingDots/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/EmailForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/NameForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/toaster.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/use-toast.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Toasts/toast.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Input/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Input/Input.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Card/Card.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Card/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/PasswordSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/OauthSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/Signup.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/UpdatePassword.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/Separator.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/EmailSignIn.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/AuthForms/ForgotPassword.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Footer/Footer.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Footer/index.ts
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navbar.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navlinks.tsx
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/index.ts
/tmp/inputs/nextjs-subscription-payments/utils/helpers.ts
/tmp/inputs/nextjs-subscription-payments/utils/cn.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts
/tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/settings.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts
/tmp/inputs/nextjs-subscription-payments/app/layout.tsx


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments
output
Here're the files and directories up to 2 levels deep in /tmp/inputs/nextjs-subscription-payments, excluding hidden items and node_modules:
2.3M	/tmp/inputs/nextjs-subscription-payments
1.5K	/tmp/inputs/nextjs-subscription-payments/LICENSE
16K	/tmp/inputs/nextjs-subscription-payments/README.md
81K	/tmp/inputs/nextjs-subscription-payments/app
1.5K	/tmp/inputs/nextjs-subscription-payments/app/account
3.5K	/tmp/inputs/nextjs-subscription-payments/app/api
3.0K	/tmp/inputs/nextjs-subscription-payments/app/auth
1.5K	/tmp/inputs/nextjs-subscription-payments/app/layout.tsx
66K	/tmp/inputs/nextjs-subscription-payments/app/opengraph-image.png
1.0K	/tmp/inputs/nextjs-subscription-payments/app/page.tsx
4.5K	/tmp/inputs/nextjs-subscription-payments/app/signin
62K	/tmp/inputs/nextjs-subscription-payments/components
512	/tmp/inputs/nextjs-subscription-payments/components.json
2.5K	/tmp/inputs/nextjs-subscription-payments/components/icons
60K	/tmp/inputs/nextjs-subscription-payments/components/ui
2.0K	/tmp/inputs/nextjs-subscription-payments/fixtures
2.0K	/tmp/inputs/nextjs-subscription-payments/fixtures/stripe-fixtures.json
1.0K	/tmp/inputs/nextjs-subscription-payments/middleware.ts
512	/tmp/inputs/nextjs-subscription-payments/next-env.d.ts
2.5K	/tmp/inputs/nextjs-subscription-payments/package.json
129K	/tmp/inputs/nextjs-subscription-payments/pnpm-lock.yaml
512	/tmp/inputs/nextjs-subscription-payments/postcss.config.js
532K	/tmp/inputs/nextjs-subscription-payments/public
136K	/tmp/inputs/nextjs-subscription-payments/public/architecture_diagram.png
7.5K	/tmp/inputs/nextjs-subscription-payments/public/architecture_diagram.svg
255K	/tmp/inputs/nextjs-subscription-payments/public/demo.png
1.0K	/tmp/inputs/nextjs-subscription-payments/public/favicon.ico
3.0K	/tmp/inputs/nextjs-subscription-payments/public/github.svg
4.0K	/tmp/inputs/nextjs-subscription-payments/public/nextjs.svg
2.0K	/tmp/inputs/nextjs-subscription-payments/public/stripe.svg
5.5K	/tmp/inputs/nextjs-subscription-payments/public/supabase.svg
115K	/tmp/inputs/nextjs-subscription-payments/public/vercel-deploy.png
2.5K	/tmp/inputs/nextjs-subscription-payments/public/vercel.svg
7.5K	/tmp/inputs/nextjs-subscription-payments/schema.sql
1.0K	/tmp/inputs/nextjs-subscription-payments/styles
1.0K	/tmp/inputs/nextjs-subscription-payments/styles/main.css
14K	/tmp/inputs/nextjs-subscription-payments/supabase
6.0K	/tmp/inputs/nextjs-subscription-payments/supabase/config.toml
7.5K	/tmp/inputs/nextjs-subscription-payments/supabase/migrations
0	/tmp/inputs/nextjs-subscription-payments/supabase/seed.sql
1.0K	/tmp/inputs/nextjs-subscription-payments/tailwind.config.js
1.0K	/tmp/inputs/nextjs-subscription-payments/tsconfig.json
20K	/tmp/inputs/nextjs-subscription-payments/types_db.ts
38K	/tmp/inputs/nextjs-subscription-payments/utils
12K	/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers
512	/tmp/inputs/nextjs-subscription-payments/utils/cn.ts
3.5K	/tmp/inputs/nextjs-subscription-payments/utils/helpers.ts
6.0K	/tmp/inputs/nextjs-subscription-payments/utils/stripe
17K	/tmp/inputs/nextjs-subscription-payments/utils/supabase



str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase
output
Here're the files and directories up to 2 levels deep in /tmp/inputs/nextjs-subscription-payments/utils/supabase, excluding hidden items and node_modules:
17K	/tmp/inputs/nextjs-subscription-payments/utils/supabase
10K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
512	/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
2.5K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts
1.5K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
2.0K	/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts



str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/client.ts with line numbers:
1	import { createBrowserClient } from '@supabase/ssr';
2	import { Database } from '@/types_db';
3
4	// Define a function to create a Supabase client for client-side operations
5	export const createClient = () =>
6	  createBrowserClient<Database>(
7	    // Pass Supabase URL and anonymous key from the environment to the client
8	    process.env.NEXT_PUBLIC_SUPABASE_URL!,
9	    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
10	  );
11	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/server.ts with line numbers:
1	import { createServerClient, type CookieOptions } from '@supabase/ssr';
2	import { cookies } from 'next/headers';
3	import { Database } from '@/types_db';
4
5	// Define a function to create a Supabase client for server-side operations
6	// The function takes a cookie store created with next/headers cookies as an argument
7	export const createClient = () => {
8	  const cookieStore = cookies();
9
10	  return createServerClient<Database>(
11	    // Pass Supabase URL and anonymous key from the environment to the client
12	    process.env.NEXT_PUBLIC_SUPABASE_URL!,
13	    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
14
15	    // Define a cookies object with methods for interacting with the cookie store and pass it to the client
16	    {
17	      cookies: {
18	        // The get method is used to retrieve a cookie by its name
19	        get(name: string) {
20	          return cookieStore.get(name)?.value;
21	        },
22	        // The set method is used to set a cookie with a given name, value, and options
23	        set(name: string, value: string, options: CookieOptions) {
24	          try {
25	            cookieStore.set({ name, value, ...options });
26	          } catch (error) {
27	            // If the set method is called from a Server Component, an error may occur
28	            // This can be ignored if there is middleware refreshing user sessions
29	          }
30	        },
31	        // The remove method is used to delete a cookie by its name
32	        remove(name: string, options: CookieOptions) {
33	          try {
34	            cookieStore.set({ name, value: '', ...options });
35	          } catch (error) {
36	            // If the remove method is called from a Server Component, an error may occur
37	            // This can be ignored if there is middleware refreshing user sessions
38	          }
39	        }
40	      }
41	    }
42	  );
43	};
44	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/admin.ts with line numbers:
1	import { toDateTime } from '@/utils/helpers';
2	import { stripe } from '@/utils/stripe/config';
3	import { createClient } from '@supabase/supabase-js';
4	import Stripe from 'stripe';
5	import type { Database, Tables, TablesInsert } from 'types_db';
6
7	type Product = Tables<'products'>;
8	type Price = Tables<'prices'>;
9
10	// Change to control trial period length
11	const TRIAL_PERIOD_DAYS = 0;
12
13	// Note: supabaseAdmin uses the SERVICE_ROLE_KEY which you must only use in a secure server-side context
14	// as it has admin privileges and overwrites RLS policies!
15	const supabaseAdmin = createClient<Database>(
16	  process.env.NEXT_PUBLIC_SUPABASE_URL || '',
17	  process.env.SUPABASE_SERVICE_ROLE_KEY || ''
18	);
19
20	const upsertProductRecord = async (product: Stripe.Product) => {
21	  const productData: Product = {
22	    id: product.id,
23	    active: product.active,
24	    name: product.name,
25	    description: product.description ?? null,
26	    image: product.images?.[0] ?? null,
27	    metadata: product.metadata
28	  };
29
30	  const { error: upsertError } = await supabaseAdmin
31	    .from('products')
32	    .upsert([productData]);
33	  if (upsertError)
34	    throw new Error(`Product insert/update failed: ${upsertError.message}`);
35	  console.log(`Product inserted/updated: ${product.id}`);
36	};
37
38	const upsertPriceRecord = async (
39	  price: Stripe.Price,
40	  retryCount = 0,
41	  maxRetries = 3
42	) => {
43	  const priceData: Price = {
44	    id: price.id,
45	    product_id: typeof price.product === 'string' ? price.product : '',
46	    active: price.active,
47	    currency: price.currency,
48	    type: price.type,
49	    unit_amount: price.unit_amount ?? null,
50	    interval: price.recurring?.interval ?? null,
51	    interval_count: price.recurring?.interval_count ?? null,
52	    trial_period_days: price.recurring?.trial_period_days ?? TRIAL_PERIOD_DAYS
53	  };
54
55	  const { error: upsertError } = await supabaseAdmin
56	    .from('prices')
57	    .upsert([priceData]);
58
59	  if (upsertError?.message.includes('foreign key constraint')) {
60	    if (retryCount < maxRetries) {
61	      console.log(`Retry attempt ${retryCount + 1} for price ID: ${price.id}`);
62	      await new Promise((resolve) => setTimeout(resolve, 2000));
63	      await upsertPriceRecord(price, retryCount + 1, maxRetries);
64	    } else {
65	      throw new Error(
66	        `Price insert/update failed after ${maxRetries} retries: ${upsertError.message}`
67	      );
68	    }
69	  } else if (upsertError) {
70	    throw new Error(`Price insert/update failed: ${upsertError.message}`);
71	  } else {
72	    console.log(`Price inserted/updated: ${price.id}`);
73	  }
74	};
75
76	const deleteProductRecord = async (product: Stripe.Product) => {
77	  const { error: deletionError } = await supabaseAdmin
78	    .from('products')
79	    .delete()
80	    .eq('id', product.id);
81	  if (deletionError)
82	    throw new Error(`Product deletion failed: ${deletionError.message}`);
83	  console.log(`Product deleted: ${product.id}`);
84	};
85
86	const deletePriceRecord = async (price: Stripe.Price) => {
87	  const { error: deletionError } = await supabaseAdmin
88	    .from('prices')
89	    .delete()
90	    .eq('id', price.id);
91	  if (deletionError) throw new Error(`Price deletion failed: ${deletionError.message}`);
92	  console.log(`Price deleted: ${price.id}`);
93	};
94
95	const upsertCustomerToSupabase = async (uuid: string, customerId: string) => {
96	  const { error: upsertError } = await supabaseAdmin
97	    .from('customers')
98	    .upsert([{ id: uuid, stripe_customer_id: customerId }]);
99
100	  if (upsertError)
101	    throw new Error(`Supabase customer record creation failed: ${upsertError.message}`);
102
103	  return customerId;
104	};
105
106	const createCustomerInStripe = async (uuid: string, email: string) => {
107	  const customerData = { metadata: { supabaseUUID: uuid }, email: email };
108	  const newCustomer = await stripe.customers.create(customerData);
109	  if (!newCustomer) throw new Error('Stripe customer creation failed.');
110
111	  return newCustomer.id;
112	};
113
114	const createOrRetrieveCustomer = async ({
115	  email,
116	  uuid
117	}: {
118	  email: string;
119	  uuid: string;
120	}) => {
121	  // Check if the customer already exists in Supabase
122	  const { data: existingSupabaseCustomer, error: queryError } =
123	    await supabaseAdmin
124	      .from('customers')
125	      .select('*')
126	      .eq('id', uuid)
127	      .maybeSingle();
128
129	  if (queryError) {
130	    throw new Error(`Supabase customer lookup failed: ${queryError.message}`);
131	  }
132
133	  // Retrieve the Stripe customer ID using the Supabase customer ID, with email fallback
134	  let stripeCustomerId: string | undefined;
135	  if (existingSupabaseCustomer?.stripe_customer_id) {
136	    const existingStripeCustomer = await stripe.customers.retrieve(
137	      existingSupabaseCustomer.stripe_customer_id
138	    );
139	    stripeCustomerId = existingStripeCustomer.id;
140	  } else {
141	    // If Stripe ID is missing from Supabase, try to retrieve Stripe customer ID by email
142	    const stripeCustomers = await stripe.customers.list({ email: email });
143	    stripeCustomerId =
144	      stripeCustomers.data.length > 0 ? stripeCustomers.data[0].id : undefined;
145	  }
146
147	  // If still no stripeCustomerId, create a new customer in Stripe
148	  const stripeIdToInsert = stripeCustomerId
149	    ? stripeCustomerId
150	    : await createCustomerInStripe(uuid, email);
151	  if (!stripeIdToInsert) throw new Error('Stripe customer creation failed.');
152
153	  if (existingSupabaseCustomer && stripeCustomerId) {
154	    // If Supabase has a record but doesn't match Stripe, update Supabase record
155	    if (existingSupabaseCustomer.stripe_customer_id !== stripeCustomerId) {
156	      const { error: updateError } = await supabaseAdmin
157	        .from('customers')
158	        .update({ stripe_customer_id: stripeCustomerId })
159	        .eq('id', uuid);
160
161	      if (updateError)
162	        throw new Error(
163	          `Supabase customer record update failed: ${updateError.message}`
164	        );
165	      console.warn(
166	        `Supabase customer record mismatched Stripe ID. Supabase record updated.`
167	      );
168	    }
169	    // If Supabase has a record and matches Stripe, return Stripe customer ID
170	    return stripeCustomerId;
171	  } else {
172	    console.warn(
173	      `Supabase customer record was missing. A new record was created.`
174	    );
175
176	    // If Supabase has no record, create a new record and return Stripe customer ID
177	    const upsertedStripeCustomer = await upsertCustomerToSupabase(
178	      uuid,
179	      stripeIdToInsert
180	    );
181	    if (!upsertedStripeCustomer)
182	      throw new Error('Supabase customer record creation failed.');
183
184	    return upsertedStripeCustomer;
185	  }
186	};
187
188	/**
189	 * Copies the billing details from the payment method to the customer object.
190	 */
191	const copyBillingDetailsToCustomer = async (
192	  uuid: string,
193	  payment_method: Stripe.PaymentMethod
194	) => {
195	  //Todo: check this assertion
196	  const customer = payment_method.customer as string;
197	  const { name, phone, address } = payment_method.billing_details;
198	  if (!name || !phone || !address) return;
199	  //@ts-ignore
200	  await stripe.customers.update(customer, { name, phone, address });
201	  const { error: updateError } = await supabaseAdmin
202	    .from('users')
203	    .update({
204	      billing_address: { ...address },
205	      payment_method: { ...payment_method[payment_method.type] }
206	    })
207	    .eq('id', uuid);
208	  if (updateError) throw new Error(`Customer update failed: ${updateError.message}`);
209	};
210
211	const manageSubscriptionStatusChange = async (
212	  subscriptionId: string,
213	  customerId: string,
214	  createAction = false
215	) => {
216	  // Get customer's UUID from mapping table.
217	  const { data: customerData, error: noCustomerError } = await supabaseAdmin
218	    .from('customers')
219	    .select('id')
220	    .eq('stripe_customer_id', customerId)
221	    .single();
222
223	  if (noCustomerError)
224	    throw new Error(`Customer lookup failed: ${noCustomerError.message}`);
225
226	  const { id: uuid } = customerData!;
227
228	  const subscription = await stripe.subscriptions.retrieve(subscriptionId, {
229	    expand: ['default_payment_method']
230	  });
231	  // Upsert the latest status of the subscription object.
232	  const subscriptionData: TablesInsert<'subscriptions'> = {
233	    id: subscription.id,
234	    user_id: uuid,
235	    metadata: subscription.metadata,
236	    status: subscription.status,
237	    price_id: subscription.items.data[0].price.id,
238	    //TODO check quantity on subscription
239	    // @ts-ignore
240	    quantity: subscription.quantity,
241	    cancel_at_period_end: subscription.cancel_at_period_end,
242	    cancel_at: subscription.cancel_at
243	      ? toDateTime(subscription.cancel_at).toISOString()
244	      : null,
245	    canceled_at: subscription.canceled_at
246	      ? toDateTime(subscription.canceled_at).toISOString()
247	      : null,
248	    current_period_start: toDateTime(
249	      subscription.current_period_start
250	    ).toISOString(),
251	    current_period_end: toDateTime(
252	      subscription.current_period_end
253	    ).toISOString(),
254	    created: toDateTime(subscription.created).toISOString(),
255	    ended_at: subscription.ended_at
256	      ? toDateTime(subscription.ended_at).toISOString()
257	      : null,
258	    trial_start: subscription.trial_start
259	      ? toDateTime(subscription.trial_start).toISOString()
260	      : null,
261	    trial_end: subscription.trial_end
262	      ? toDateTime(subscription.trial_end).toISOString()
263	      : null
264	  };
265
266	  const { error: upsertError } = await supabaseAdmin
267	    .from('subscriptions')
268	    .upsert([subscriptionData]);
269	  if (upsertError)
270	    throw new Error(`Subscription insert/update failed: ${upsertError.message}`);
271	  console.log(
272	    `Inserted/updated subscription [${subscription.id}] for user [${uuid}]`
273	  );
274
275	  // For a new subscription copy the billing details to the customer object.
276	  // NOTE: This is a costly operation and should happen at the very end.
277	  if (createAction && subscription.default_payment_method && uuid)
278	    //@ts-ignore
279	    await copyBillingDetailsToCustomer(
280	      uuid,
281	      subscription.default_payment_method as Stripe.PaymentMethod
282	    );
283	};
284
285	export {
286	  upsertProductRecord,
287	  upsertPriceRecord,
288	  deleteProductRecord,
289	  deletePriceRecord,
290	  createOrRetrieveCustomer,
291	  manageSubscriptionStatusChange
292	};
293	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/config.ts with line numbers:
1	import Stripe from 'stripe';
2
3	export const stripe = new Stripe(
4	  process.env.STRIPE_SECRET_KEY_LIVE ?? process.env.STRIPE_SECRET_KEY ?? '',
5	  {
6	    // https://github.com/stripe/stripe-node#configuration
7	    // https://stripe.com/docs/api/versioning
8	    // @ts-ignore
9	    apiVersion: null,
10	    // Register this as an official Stripe plugin.
11	    // https://stripe.com/docs/building-plugins#setappinfo
12	    appInfo: {
13	      name: 'Next.js Subscription Starter',
14	      version: '0.0.0',
15	      url: 'https://github.com/vercel/nextjs-subscription-payments'
16	    }
17	  }
18	);
19	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/server.ts with line numbers:
1	'use server';
2
3	import Stripe from 'stripe';
4	import { stripe } from '@/utils/stripe/config';
5	import { createClient } from '@/utils/supabase/server';
6	import { createOrRetrieveCustomer } from '@/utils/supabase/admin';
7	import {
8	  getURL,
9	  getErrorRedirect,
10	  calculateTrialEndUnixTimestamp
11	} from '@/utils/helpers';
12	import { Tables } from '@/types_db';
13
14	type Price = Tables<'prices'>;
15
16	type CheckoutResponse = {
17	  errorRedirect?: string;
18	  sessionId?: string;
19	};
20
21	export async function checkoutWithStripe(
22	  price: Price,
23	  redirectPath: string = '/account'
24	): Promise<CheckoutResponse> {
25	  try {
26	    // Get the user from Supabase auth
27	    const supabase = createClient();
28	    const {
29	      error,
30	      data: { user }
31	    } = await supabase.auth.getUser();
32
33	    if (error || !user) {
34	      console.error(error);
35	      throw new Error('Could not get user session.');
36	    }
37
38	    // Retrieve or create the customer in Stripe
39	    let customer: string;
40	    try {
41	      customer = await createOrRetrieveCustomer({
42	        uuid: user?.id || '',
43	        email: user?.email || ''
44	      });
45	    } catch (err) {
46	      console.error(err);
47	      throw new Error('Unable to access customer record.');
48	    }
49
50	    let params: Stripe.Checkout.SessionCreateParams = {
51	      allow_promotion_codes: true,
52	      billing_address_collection: 'required',
53	      customer,
54	      customer_update: {
55	        address: 'auto'
56	      },
57	      line_items: [
58	        {
59	          price: price.id,
60	          quantity: 1
61	        }
62	      ],
63	      cancel_url: getURL(),
64	      success_url: getURL(redirectPath)
65	    };
66
67	    console.log(
68	      'Trial end:',
69	      calculateTrialEndUnixTimestamp(price.trial_period_days)
70	    );
71	    if (price.type === 'recurring') {
72	      params = {
73	        ...params,
74	        mode: 'subscription',
75	        subscription_data: {
76	          trial_end: calculateTrialEndUnixTimestamp(price.trial_period_days)
77	        }
78	      };
79	    } else if (price.type === 'one_time') {
80	      params = {
81	        ...params,
82	        mode: 'payment'
83	      };
84	    }
85
86	    // Create a checkout session in Stripe
87	    let session;
88	    try {
89	      session = await stripe.checkout.sessions.create(params);
90	    } catch (err) {
91	      console.error(err);
92	      throw new Error('Unable to create checkout session.');
93	    }
94
95	    // Instead of returning a Response, just return the data or error.
96	    if (session) {
97	      return { sessionId: session.id };
98	    } else {
99	      throw new Error('Unable to create checkout session.');
100	    }
101	  } catch (error) {
102	    if (error instanceof Error) {
103	      return {
104	        errorRedirect: getErrorRedirect(
105	          redirectPath,
106	          error.message,
107	          'Please try again later or contact a system administrator.'
108	        )
109	      };
110	    } else {
111	      return {
112	        errorRedirect: getErrorRedirect(
113	          redirectPath,
114	          'An unknown error occurred.',
115	          'Please try again later or contact a system administrator.'
116	        )
117	      };
118	    }
119	  }
120	}
121
122	export async function createStripePortal(currentPath: string) {
123	  try {
124	    const supabase = createClient();
125	    const {
126	      error,
127	      data: { user }
128	    } = await supabase.auth.getUser();
129
130	    if (!user) {
131	      if (error) {
132	        console.error(error);
133	      }
134	      throw new Error('Could not get user session.');
135	    }
136
137	    let customer;
138	    try {
139	      customer = await createOrRetrieveCustomer({
140	        uuid: user.id || '',
141	        email: user.email || ''
142	      });
143	    } catch (err) {
144	      console.error(err);
145	      throw new Error('Unable to access customer record.');
146	    }
147
148	    if (!customer) {
149	      throw new Error('Could not get customer.');
150	    }
151
152	    try {
153	      const { url } = await stripe.billingPortal.sessions.create({
154	        customer,
155	        return_url: getURL('/account')
156	      });
157	      if (!url) {
158	        throw new Error('Could not create billing portal');
159	      }
160	      return url;
161	    } catch (err) {
162	      console.error(err);
163	      throw new Error('Could not create billing portal');
164	    }
165	  } catch (error) {
166	    if (error instanceof Error) {
167	      console.error(error);
168	      return getErrorRedirect(
169	        currentPath,
170	        error.message,
171	        'Please try again later or contact a system administrator.'
172	      );
173	    } else {
174	      return getErrorRedirect(
175	        currentPath,
176	        'An unknown error occurred.',
177	        'Please try again later or contact a system administrator.'
178	      );
179	    }
180	  }
181	}
182	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/queries.ts with line numbers:
1	import { SupabaseClient } from '@supabase/supabase-js';
2	import { cache } from 'react';
3
4	export const getUser = cache(async (supabase: SupabaseClient) => {
5	  const {
6	    data: { user }
7	  } = await supabase.auth.getUser();
8	  return user;
9	});
10
11	export const getSubscription = cache(async (supabase: SupabaseClient) => {
12	  const { data: subscription, error } = await supabase
13	    .from('subscriptions')
14	    .select('*, prices(*, products(*))')
15	    .in('status', ['trialing', 'active'])
16	    .maybeSingle();
17
18	  return subscription;
19	});
20
21	export const getProducts = cache(async (supabase: SupabaseClient) => {
22	  const { data: products, error } = await supabase
23	    .from('products')
24	    .select('*, prices(*)')
25	    .eq('active', true)
26	    .eq('prices.active', true)
27	    .order('metadata->index')
28	    .order('unit_amount', { referencedTable: 'prices' });
29
30	  return products;
31	});
32
33	export const getUserDetails = cache(async (supabase: SupabaseClient) => {
34	  const { data: userDetails } = await supabase
35	    .from('users')
36	    .select('*')
37	    .single();
38	  return userDetails;
39	});
40	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/app/page.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/app/page.tsx with line numbers:
1	import Pricing from '@/components/ui/Pricing/Pricing';
2	import { createClient } from '@/utils/supabase/server';
3	import {
4	  getProducts,
5	  getSubscription,
6	  getUser
7	} from '@/utils/supabase/queries';
8
9	export default async function PricingPage() {
10	  const supabase = createClient();
11	  const [user, products, subscription] = await Promise.all([
12	    getUser(supabase),
13	    getProducts(supabase),
14	    getSubscription(supabase)
15	  ]);
16
17	  return (
18	    <Pricing
19	      user={user}
20	      products={products ?? []}
21	      subscription={subscription}
22	    />
23	  );
24	}
25	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/Pricing/Pricing.tsx with line numbers:
1	'use client';
2
3	import Button from '@/components/ui/Button';
4	import LogoCloud from '@/components/ui/LogoCloud';
5	import type { Tables } from '@/types_db';
6	import { getStripe } from '@/utils/stripe/client';
7	import { checkoutWithStripe } from '@/utils/stripe/server';
8	import { getErrorRedirect } from '@/utils/helpers';
9	import { User } from '@supabase/supabase-js';
10	import cn from 'classnames';
11	import { useRouter, usePathname } from 'next/navigation';
12	import { useState } from 'react';
13
14	type Subscription = Tables<'subscriptions'>;
15	type Product = Tables<'products'>;
16	type Price = Tables<'prices'>;
17	interface ProductWithPrices extends Product {
18	  prices: Price[];
19	}
20	interface PriceWithProduct extends Price {
21	  products: Product | null;
22	}
23	interface SubscriptionWithProduct extends Subscription {
24	  prices: PriceWithProduct | null;
25	}
26
27	interface Props {
28	  user: User | null | undefined;
29	  products: ProductWithPrices[];
30	  subscription: SubscriptionWithProduct | null;
31	}
32
33	type BillingInterval = 'lifetime' | 'year' | 'month';
34
35	export default function Pricing({ user, products, subscription }: Props) {
36	  const intervals = Array.from(
37	    new Set(
38	      products.flatMap((product) =>
39	        product?.prices?.map((price) => price?.interval)
40	      )
41	    )
42	  );
43	  const router = useRouter();
44	  const [billingInterval, setBillingInterval] =
45	    useState<BillingInterval>('month');
46	  const [priceIdLoading, setPriceIdLoading] = useState<string>();
47	  const currentPath = usePathname();
48
49	  const handleStripeCheckout = async (price: Price) => {
50	    setPriceIdLoading(price.id);
51
52	    if (!user) {
53	      setPriceIdLoading(undefined);
54	      return router.push('/signin/signup');
55	    }
56
57	    const { errorRedirect, sessionId } = await checkoutWithStripe(
58	      price,
59	      currentPath
60	    );
61
62	    if (errorRedirect) {
63	      setPriceIdLoading(undefined);
64	      return router.push(errorRedirect);
65	    }
66
67	    if (!sessionId) {
68	      setPriceIdLoading(undefined);
69	      return router.push(
70	        getErrorRedirect(
71	          currentPath,
72	          'An unknown error occurred.',
73	          'Please try again later or contact a system administrator.'
74	        )
75	      );
76	    }
77
78	    const stripe = await getStripe();
79	    stripe?.redirectToCheckout({ sessionId });
80
81	    setPriceIdLoading(undefined);
82	  };
83
84	  if (!products.length) {
85	    return (
86	      <section className="bg-black">
87	        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
88	          <div className="sm:flex sm:flex-col sm:align-center"></div>
89	          <p className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
90	            No subscription pricing plans found. Create them in your{' '}
91	            <a
92	              className="text-pink-500 underline"
93	              href="https://dashboard.stripe.com/products"
94	              rel="noopener noreferrer"
95	              target="_blank"
96	            >
97	              Stripe Dashboard
98	            </a>
99	            .
100	          </p>
101	        </div>
102	        <LogoCloud />
103	      </section>
104	    );
105	  } else {
106	    return (
107	      <section className="bg-black">
108	        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
109	          <div className="sm:flex sm:flex-col sm:align-center">
110	            <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
111	              Pricing Plans
112	            </h1>
113	            <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
114	              Start building for free, then add a site plan to go live. Account
115	              plans unlock additional features.
116	            </p>
117	            <div className="relative self-center mt-6 bg-zinc-900 rounded-lg p-0.5 flex sm:mt-8 border border-zinc-800">
118	              {intervals.includes('month') && (
119	                <button
120	                  onClick={() => setBillingInterval('month')}
121	                  type="button"
122	                  className={`${
123	                    billingInterval === 'month'
124	                      ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
125	                      : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
126	                  } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
127	                >
128	                  Monthly billing
129	                </button>
130	              )}
131	              {intervals.includes('year') && (
132	                <button
133	                  onClick={() => setBillingInterval('year')}
134	                  type="button"
135	                  className={`${
136	                    billingInterval === 'year'
137	                      ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
138	                      : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
139	                  } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
140	                >
141	                  Yearly billing
142	                </button>
143	              )}
144	            </div>
145	          </div>
146	          <div className="mt-12 space-y-0 sm:mt-16 flex flex-wrap justify-center gap-6 lg:max-w-4xl lg:mx-auto xl:max-w-none xl:mx-0">
147	            {products.map((product) => {
148	              const price = product?.prices?.find(
149	                (price) => price.interval === billingInterval
150	              );
151	              if (!price) return null;
152	              const priceString = new Intl.NumberFormat('en-US', {
153	                style: 'currency',
154	                currency: price.currency!,
155	                minimumFractionDigits: 0
156	              }).format((price?.unit_amount || 0) / 100);
157	              return (
158	                <div
159	                  key={product.id}
160	                  className={cn(
161	                    'flex flex-col rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900',
162	                    {
163	                      'border border-pink-500': subscription
164	                        ? product.name === subscription?.prices?.products?.name
165	                        : product.name === 'Freelancer'
166	                    },
167	                    'flex-1', // This makes the flex item grow to fill the space
168	                    'basis-1/3', // Assuming you want each card to take up roughly a third of the container's width
169	                    'max-w-xs' // Sets a maximum width to the cards to prevent them from getting too large
170	                  )}
171	                >
172	                  <div className="p-6">
173	                    <h2 className="text-2xl font-semibold leading-6 text-white">
174	                      {product.name}
175	                    </h2>
176	                    <p className="mt-4 text-zinc-300">{product.description}</p>
177	                    <p className="mt-8">
178	                      <span className="text-5xl font-extrabold white">
179	                        {priceString}
180	                      </span>
181	                      <span className="text-base font-medium text-zinc-100">
182	                        /{billingInterval}
183	                      </span>
184	                    </p>
185	                    <Button
186	                      variant="slim"
187	                      type="button"
188	                      loading={priceIdLoading === price.id}
189	                      onClick={() => handleStripeCheckout(price)}
190	                      className="block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900"
191	                    >
192	                      {subscription ? 'Manage' : 'Subscribe'}
193	                    </Button>
194	                  </div>
195	                </div>
196	              );
197	            })}
198	          </div>
199	          <LogoCloud />
200	        </div>
201	      </section>
202	    );
203	  }
204	}
205	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/auth-helpers/server.ts with line numbers:
1	'use server';
2
3	import { createClient } from '@/utils/supabase/server';
4	import { cookies } from 'next/headers';
5	import { redirect } from 'next/navigation';
6	import { getURL, getErrorRedirect, getStatusRedirect } from 'utils/helpers';
7	import { getAuthTypes } from 'utils/auth-helpers/settings';
8
9	function isValidEmail(email: string) {
10	  var regex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
11	  return regex.test(email);
12	}
13
14	export async function redirectToPath(path: string) {
15	  return redirect(path);
16	}
17
18	export async function SignOut(formData: FormData) {
19	  const pathName = String(formData.get('pathName')).trim();
20
21	  const supabase = createClient();
22	  const { error } = await supabase.auth.signOut();
23
24	  if (error) {
25	    return getErrorRedirect(
26	      pathName,
27	      'Hmm... Something went wrong.',
28	      'You could not be signed out.'
29	    );
30	  }
31
32	  return '/signin';
33	}
34
35	export async function signInWithEmail(formData: FormData) {
36	  const cookieStore = cookies();
37	  const callbackURL = getURL('/auth/callback');
38
39	  const email = String(formData.get('email')).trim();
40	  let redirectPath: string;
41
42	  if (!isValidEmail(email)) {
43	    redirectPath = getErrorRedirect(
44	      '/signin/email_signin',
45	      'Invalid email address.',
46	      'Please try again.'
47	    );
48	  }
49
50	  const supabase = createClient();
51	  let options = {
52	    emailRedirectTo: callbackURL,
53	    shouldCreateUser: true
54	  };
55
56	  // If allowPassword is false, do not create a new user
57	  const { allowPassword } = getAuthTypes();
58	  if (allowPassword) options.shouldCreateUser = false;
59	  const { data, error } = await supabase.auth.signInWithOtp({
60	    email,
61	    options: options
62	  });
63
64	  if (error) {
65	    redirectPath = getErrorRedirect(
66	      '/signin/email_signin',
67	      'You could not be signed in.',
68	      error.message
69	    );
70	  } else if (data) {
71	    cookieStore.set('preferredSignInView', 'email_signin', { path: '/' });
72	    redirectPath = getStatusRedirect(
73	      '/signin/email_signin',
74	      'Success!',
75	      'Please check your email for a magic link. You may now close this tab.',
76	      true
77	    );
78	  } else {
79	    redirectPath = getErrorRedirect(
80	      '/signin/email_signin',
81	      'Hmm... Something went wrong.',
82	      'You could not be signed in.'
83	    );
84	  }
85
86	  return redirectPath;
87	}
88
89	export async function requestPasswordUpdate(formData: FormData) {
90	  const callbackURL = getURL('/auth/reset_password');
91
92	  // Get form data
93	  const email = String(formData.get('email')).trim();
94	  let redirectPath: string;
95
96	  if (!isValidEmail(email)) {
97	    redirectPath = getErrorRedirect(
98	      '/signin/forgot_password',
99	      'Invalid email address.',
100	      'Please try again.'
101	    );
102	  }
103
104	  const supabase = createClient();
105
106	  const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
107	    redirectTo: callbackURL
108	  });
109
110	  if (error) {
111	    redirectPath = getErrorRedirect(
112	      '/signin/forgot_password',
113	      error.message,
114	      'Please try again.'
115	    );
116	  } else if (data) {
117	    redirectPath = getStatusRedirect(
118	      '/signin/forgot_password',
119	      'Success!',
120	      'Please check your email for a password reset link. You may now close this tab.',
121	      true
122	    );
123	  } else {
124	    redirectPath = getErrorRedirect(
125	      '/signin/forgot_password',
126	      'Hmm... Something went wrong.',
127	      'Password reset email could not be sent.'
128	    );
129	  }
130
131	  return redirectPath;
132	}
133
134	export async function signInWithPassword(formData: FormData) {
135	  const cookieStore = cookies();
136	  const email = String(formData.get('email')).trim();
137	  const password = String(formData.get('password')).trim();
138	  let redirectPath: string;
139
140	  const supabase = createClient();
141	  const { error, data } = await supabase.auth.signInWithPassword({
142	    email,
143	    password
144	  });
145
146	  if (error) {
147	    redirectPath = getErrorRedirect(
148	      '/signin/password_signin',
149	      'Sign in failed.',
150	      error.message
151	    );
152	  } else if (data.user) {
153	    cookieStore.set('preferredSignInView', 'password_signin', { path: '/' });
154	    redirectPath = getStatusRedirect('/', 'Success!', 'You are now signed in.');
155	  } else {
156	    redirectPath = getErrorRedirect(
157	      '/signin/password_signin',
158	      'Hmm... Something went wrong.',
159	      'You could not be signed in.'
160	    );
161	  }
162
163	  return redirectPath;
164	}
165
166	export async function signUp(formData: FormData) {
167	  const callbackURL = getURL('/auth/callback');
168
169	  const email = String(formData.get('email')).trim();
170	  const password = String(formData.get('password')).trim();
171	  let redirectPath: string;
172
173	  if (!isValidEmail(email)) {
174	    redirectPath = getErrorRedirect(
175	      '/signin/signup',
176	      'Invalid email address.',
177	      'Please try again.'
178	    );
179	  }
180
181	  const supabase = createClient();
182	  const { error, data } = await supabase.auth.signUp({
183	    email,
184	    password,
185	    options: {
186	      emailRedirectTo: callbackURL
187	    }
188	  });
189
190	  if (error) {
191	    redirectPath = getErrorRedirect(
192	      '/signin/signup',
193	      'Sign up failed.',
194	      error.message
195	    );
196	  } else if (data.session) {
197	    redirectPath = getStatusRedirect('/', 'Success!', 'You are now signed in.');
198	  } else if (
199	    data.user &&
200	    data.user.identities &&
201	    data.user.identities.length == 0
202	  ) {
203	    redirectPath = getErrorRedirect(
204	      '/signin/signup',
205	      'Sign up failed.',
206	      'There is already an account associated with this email address. Try resetting your password.'
207	    );
208	  } else if (data.user) {
209	    redirectPath = getStatusRedirect(
210	      '/',
211	      'Success!',
212	      'Please check your email for a confirmation link. You may now close this tab.'
213	    );
214	  } else {
215	    redirectPath = getErrorRedirect(
216	      '/signin/signup',
217	      'Hmm... Something went wrong.',
218	      'You could not be signed up.'
219	    );
220	  }
221
222	  return redirectPath;
223	}
224
225	export async function updatePassword(formData: FormData) {
226	  const password = String(formData.get('password')).trim();
227	  const passwordConfirm = String(formData.get('passwordConfirm')).trim();
228	  let redirectPath: string;
229
230	  // Check that the password and confirmation match
231	  if (password !== passwordConfirm) {
232	    redirectPath = getErrorRedirect(
233	      '/signin/update_password',
234	      'Your password could not be updated.',
235	      'Passwords do not match.'
236	    );
237	  }
238
239	  const supabase = createClient();
240	  const { error, data } = await supabase.auth.updateUser({
241	    password
242	  });
243
244	  if (error) {
245	    redirectPath = getErrorRedirect(
246	      '/signin/update_password',
247	      'Your password could not be updated.',
248	      error.message
249	    );
250	  } else if (data.user) {
251	    redirectPath = getStatusRedirect(
252	      '/',
253	      'Success!',
254	      'Your password has been updated.'
255	    );
256	  } else {
257	    redirectPath = getErrorRedirect(
258	      '/signin/update_password',
259	      'Hmm... Something went wrong.',
260	      'Your password could not be updated.'
261	    );
262	  }
263
264	  return redirectPath;
265	}
266
267	export async function updateEmail(formData: FormData) {
268	  // Get form data
269	  const newEmail = String(formData.get('newEmail')).trim();
270
271	  // Check that the email is valid
272	  if (!isValidEmail(newEmail)) {
273	    return getErrorRedirect(
274	      '/account',
275	      'Your email could not be updated.',
276	      'Invalid email address.'
277	    );
278	  }
279
280	  const supabase = createClient();
281
282	  const callbackUrl = getURL(
283	    getStatusRedirect('/account', 'Success!', `Your email has been updated.`)
284	  );
285
286	  const { error } = await supabase.auth.updateUser(
287	    { email: newEmail },
288	    {
289	      emailRedirectTo: callbackUrl
290	    }
291	  );
292
293	  if (error) {
294	    return getErrorRedirect(
295	      '/account',
296	      'Your email could not be updated.',
297	      error.message
298	    );
299	  } else {
300	    return getStatusRedirect(
301	      '/account',
302	      'Confirmation emails sent.',
303	      `You will need to confirm the update by clicking the links sent to both the old and new email addresses.`
304	    );
305	  }
306	}
307
308	export async function updateName(formData: FormData) {
309	  // Get form data
310	  const fullName = String(formData.get('fullName')).trim();
311
312	  const supabase = createClient();
313	  const { error, data } = await supabase.auth.updateUser({
314	    data: { full_name: fullName }
315	  });
316
317	  if (error) {
318	    return getErrorRedirect(
319	      '/account',
320	      'Your name could not be updated.',
321	      error.message
322	    );
323	  } else if (data.user) {
324	    return getStatusRedirect(
325	      '/account',
326	      'Success!',
327	      'Your name has been updated.'
328	    );
329	  } else {
330	    return getErrorRedirect(
331	      '/account',
332	      'Hmm... Something went wrong.',
333	      'Your name could not be updated.'
334	    );
335	  }
336	}
337	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/app/account/page.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/app/account/page.tsx with line numbers:
1	import CustomerPortalForm from '@/components/ui/AccountForms/CustomerPortalForm';
2	import EmailForm from '@/components/ui/AccountForms/EmailForm';
3	import NameForm from '@/components/ui/AccountForms/NameForm';
4	import { redirect } from 'next/navigation';
5	import { createClient } from '@/utils/supabase/server';
6	import {
7	  getUserDetails,
8	  getSubscription,
9	  getUser
10	} from '@/utils/supabase/queries';
11
12	export default async function Account() {
13	  const supabase = createClient();
14	  const [user, userDetails, subscription] = await Promise.all([
15	    getUser(supabase),
16	    getUserDetails(supabase),
17	    getSubscription(supabase)
18	  ]);
19
20	  if (!user) {
21	    return redirect('/signin');
22	  }
23
24	  return (
25	    <section className="mb-32 bg-black">
26	      <div className="max-w-6xl px-4 py-8 mx-auto sm:px-6 sm:pt-24 lg:px-8">
27	        <div className="sm:align-center sm:flex sm:flex-col">
28	          <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
29	            Account
30	          </h1>
31	          <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
32	            We partnered with Stripe for a simplified billing.
33	          </p>
34	        </div>
35	      </div>
36	      <div className="p-4">
37	        <CustomerPortalForm subscription={subscription} />
38	        <NameForm userName={userDetails?.full_name ?? ''} />
39	        <EmailForm userEmail={user.email} />
40	      </div>
41	    </section>
42	  );
43	}
44	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/stripe/client.ts with line numbers:
1	import { loadStripe, Stripe } from '@stripe/stripe-js';
2
3	let stripePromise: Promise<Stripe | null>;
4
5	export const getStripe = () => {
6	  if (!stripePromise) {
7	    stripePromise = loadStripe(
8	      process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY_LIVE ??
9	        process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY ??
10	        ''
11	    );
12	  }
13
14	  return stripePromise;
15	};
16	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/AccountForms/CustomerPortalForm.tsx with line numbers:
1	'use client';
2
3	import Button from '@/components/ui/Button';
4	import { useRouter, usePathname } from 'next/navigation';
5	import { useState } from 'react';
6	import { createStripePortal } from '@/utils/stripe/server';
7	import Link from 'next/link';
8	import Card from '@/components/ui/Card';
9	import { Tables } from '@/types_db';
10
11	type Subscription = Tables<'subscriptions'>;
12	type Price = Tables<'prices'>;
13	type Product = Tables<'products'>;
14
15	type SubscriptionWithPriceAndProduct = Subscription & {
16	  prices:
17	    | (Price & {
18	        products: Product | null;
19	      })
20	    | null;
21	};
22
23	interface Props {
24	  subscription: SubscriptionWithPriceAndProduct | null;
25	}
26
27	export default function CustomerPortalForm({ subscription }: Props) {
28	  const router = useRouter();
29	  const currentPath = usePathname();
30	  const [isSubmitting, setIsSubmitting] = useState(false);
31
32	  const subscriptionPrice =
33	    subscription &&
34	    new Intl.NumberFormat('en-US', {
35	      style: 'currency',
36	      currency: subscription?.prices?.currency!,
37	      minimumFractionDigits: 0
38	    }).format((subscription?.prices?.unit_amount || 0) / 100);
39
40	  const handleStripePortalRequest = async () => {
41	    setIsSubmitting(true);
42	    const redirectUrl = await createStripePortal(currentPath);
43	    setIsSubmitting(false);
44	    return router.push(redirectUrl);
45	  };
46
47	  return (
48	    <Card
49	      title="Your Plan"
50	      description={
51	        subscription
52	          ? `You are currently on the ${subscription?.prices?.products?.name} plan.`
53	          : 'You are not currently subscribed to any plan.'
54	      }
55	      footer={
56	        <div className="flex flex-col items-start justify-between sm:flex-row sm:items-center">
57	          <p className="pb-4 sm:pb-0">Manage your subscription on Stripe.</p>
58	          <Button
59	            variant="slim"
60	            onClick={handleStripePortalRequest}
61	            loading={isSubmitting}
62	          >
63	            Open customer portal
64	          </Button>
65	        </div>
66	      }
67	    >
68	      <div className="mt-8 mb-4 text-xl font-semibold">
69	        {subscription ? (
70	          `${subscriptionPrice}/${subscription?.prices?.interval}`
71	        ) : (
72	          <Link href="/">Choose your plan</Link>
73	        )}
74	      </div>
75	    </Card>
76	  );
77	}
78	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navbar.tsx
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/components/ui/Navbar/Navbar.tsx with line numbers:
1	import { createClient } from '@/utils/supabase/server';
2	import s from './Navbar.module.css';
3	import Navlinks from './Navlinks';
4
5	export default async function Navbar() {
6	  const supabase = createClient();
7
8	  const {
9	    data: { user }
10	  } = await supabase.auth.getUser();
11
12	  return (
13	    <nav className={s.root}>
14	      <a href="#skip" className="sr-only focus:not-sr-only">
15	        Skip to content
16	      </a>
17	      <div className="max-w-6xl px-6 mx-auto">
18	        <Navlinks user={user} />
19	      </div>
20	    </nav>
21	  );
22	}
23	


str_replace_based_edit_tool
command
view
path
/tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts
output
Here's the content of /tmp/inputs/nextjs-subscription-payments/utils/supabase/middleware.ts with line numbers:
1	import { createServerClient, type CookieOptions } from '@supabase/ssr';
2	import { type NextRequest, NextResponse } from 'next/server';
3
4	export const createClient = (request: NextRequest) => {
5	  // Create an unmodified response
6	  let response = NextResponse.next({
7	    request: {
8	      headers: request.headers
9	    }
10	  });
11
12	  const supabase = createServerClient(
13	    process.env.NEXT_PUBLIC_SUPABASE_URL!,
14	    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
15	    {
16	      cookies: {
17	        get(name: string) {
18	          return request.cookies.get(name)?.value;
19	        },
20	        set(name: string, value: string, options: CookieOptions) {
21	          // If the cookie is updated, update the cookies for the request and response
22	          request.cookies.set({
23	            name,
24	            value,
25	            ...options
26	          });
27	          response = NextResponse.next({
28	            request: {
29	              headers: request.headers
30	            }
31	          });
32	          response.cookies.set({
33	            name,
34	            value,
35	            ...options
36	          });
37	        },
38	        remove(name: string, options: CookieOptions) {
39	          // If the cookie is removed, update the cookies for the request and response
40	          request.cookies.set({
41	            name,
42	            value: '',
43	            ...options
44	          });
45	          response = NextResponse.next({
46	            request: {
47	              headers: request.headers
48	            }
49	          });
50	          response.cookies.set({
51	            name,
52	            value: '',
53	            ...options
54	          });
55	        }
56	      }
57	    }
58	  );
59
60	  return { supabase, response };
61	};
62
63	export const updateSession = async (request: NextRequest) => {
64	  try {
65	    // This `try/catch` block is only here for the interactive tutorial.
66	    // Feel free to remove once you have Supabase connected.
67	    const { supabase, response } = createClient(request);
68
69	    // This will refresh session if expired - required for Server Components
70	    // https://supabase.com/docs/guides/auth/server-side/nextjs
71	    await supabase.auth.getUser();
72
73	    return response;
74	  } catch (e) {
75	    // If you are here, a Supabase client could not be created!
76	    // This is likely because you have not set up environment variables.
77	    // Check out http://localhost:3000 for Next Steps.
78	    return NextResponse.next({
79	      request: {
80	        headers: request.headers
81	      }
82	    });
83	  }
84	};
85	

Now I have a good understanding of the codebase. Let me provide a comprehensive answer about the dependency injection patterns used.

This codebase uses several design patterns that relate to dependency injection, though they're more aligned with modern JavaScript/TypeScript idioms than traditional DI frameworks you'd see in languages like Java or C#. Here's what's going on:

**1. Factory Function Pattern**

The primary DI-like pattern throughout the codebase is the factory function pattern. Instead of directly instantiating clients, the code exports factory functions like `createClient()` that encapsulate object creation:

- `utils/supabase/client.ts` exports `createClient()` for browser-side Supabase clients
- `utils/supabase/server.ts` exports `createClient()` for server-side Supabase clients with cookie handling
- `utils/supabase/middleware.ts` exports `createClient(request)` that takes a NextRequest and returns both a supabase client and response

This allows each consumer to request a fresh client instance configured for their specific context (browser vs server vs middleware), without needing to know the configuration details.

**2. Module-Level Singleton Pattern**

For services that should only be instantiated once, the codebase uses module-level singletons:

- In `utils/stripe/config.ts`, the Stripe client is created once at module load time and exported as `stripe`
- In `utils/supabase/admin.ts`, `supabaseAdmin` is created once with the service role key
- In `utils/stripe/client.ts`, the `getStripe()` function implements lazy singleton initialization — it only creates the Stripe promise once and reuses it on subsequent calls

**3. Parameter Injection / Constructor Injection**

The query functions in `utils/supabase/queries.ts` demonstrate a form of constructor/parameter injection. Functions like `getUser(supabase)`, `getSubscription(supabase)`, and `getProducts(supabase)` all receive a `SupabaseClient` as a parameter rather than creating one internally. This makes them flexible and testable — you can pass in any compatible client.

The consuming code in pages like `app/page.tsx` creates the client and then passes it to multiple query functions:

```typescript
const supabase = createClient();
const [user, products, subscription] = await Promise.all([
getUser(supabase),
getProducts(supabase),
getSubscription(supabase)
]);
```

**4. Environment-Based Configuration**

Configuration is injected through environment variables rather than hardcoded values. The clients read from `process.env` for things like API keys and URLs. This is a form of external configuration injection that keeps secrets out of the code and allows different configurations per deployment environment.

**What's notably absent:** The codebase doesn't use a formal DI container, decorators, or the kind of inversion-of-control framework you'd see with tools like InversifyJS or NestJS. This is pretty typical for Next.js applications, which tend to rely on simpler patterns like factory functions, module singletons, and explicit parameter passing rather than elaborate DI infrastructure. 

———MODEL B RESPONES ended!!!!——————



4. Now write the ideal answer, model a  summary, model a feedback,  model b summary model b feedback,justification. i want same level of details and evidence and writing style and lenght like this sample THIS IS SAMPLE FOR you below, READ CAREFULLY: 


SUPER IMPORTANT RULE YOU MUST FOLLOW. YOU MUST WRITE SAME WAY SAME QUALITY SAME FORMAT SAME STYLE AS SAMPLE BELOW!@!!!!!!!

——SAMPLE:—
—Every below is sample—

Ideal Response.

This ideal answer should clearly describe how Spring Petclinic wires its components through dependency injection using common patterns like constructor based injection, component scanning, and configuration-driven bean factories ...etc, and even dive deeper to explain how controllers (e.g.,src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java) declare all the collaborators in the constructors rather than in the fields, how stereotype annotations make those classes eligible for autodetection, how the repository abstractions are injected as interfaces implemented by the Spring Data JPA, and how @Configuration classes expose shared infrastructure beans that all the other components consume.
Model must explain that Spring Petclinic leans on constructor-based dependency injection to keep controllers explicit and testable. For example, it should explain controller like spring-petclinic/src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java is annotated with @Controller and declares a single constructor that takes an OwnerRepository, which has the role of letting Spring populate the dependency while preventing partially constructed instance. Model should point out that the controller never uses field injection or @Autowired on members, so the required collaborator is enforced at creation time. For example, in src/main/java/org/springframework/samples/petclinic/vet/VetController.java, whose constructor requires a VetRepository and assigns it to a final field, it is also relying on the container to supply the repository proxy. Even non-controller components follow this approach, for example src/main/java/org/springframework/samples/petclinic/owner/PetTypeFormatter.java, which is a @Component that exposes a Formatter<PetType> but takes its PetTypeRepository in the constructor, which is keeping parsing logic decoupled from storage details while still making the repository mandatory for instantiation.
Model must also explain repository layer demonstrates interface-driven injection. Interfaces such as spring-petclinic/src/main/java/org/springframework/samples/petclinic/owner/OwnerRepository.java extend Spring Data JPA’s JpaRepository, which is letting the framework auto-create runtime proxies that satisfy the dependency signatures declared in controllers and formatters.
Overall, the dependency injection explanation should ideally go deep and cover how @SpringBootApplication bootstraps component scanning, constructors declare required collaborators, repositories are injected as interfaces backed by generated proxies, and @Configuration classes publish shared infrastructure as beans.



Model A Response Summary

Model A did pretty well because it correctly identifiy constructor-based injection as the major dominant pattern and notes the absence of @Autowired, aligning with controllers like OwnerController and VetController that declare single-argument constructors for their repositories, which are src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java and src/main/java/org/springframework/samples/petclinic/vet/VetController.java,. It also correctly observes that PetTypeFormatter uses constructor injection as a component, which matches the formatters’ constructor-driven PetTypeRepository dependency. It points out that in src/main/java/org/springframework/samples/petclinic/owner/PetTypeFormatter.java, the response highlights component scanning via the stereotype annotations and the role of repository interfaces that Spring Data implements at runtime, dynamically, and consistent with the JpaRepository extension inside src/main/java/org/springframework/samples/petclinic/owner/OwnerRepository.java.  Overall, the summary gives good overview of the core DI patterns present in the codebase.
Model A Response Feedback

the answer is strong on constructor injection and the lack of @Autowired, both supported by the controller and formatter classes cited in summary above, which are very impressive findings in my opinion as tehy’re not that obvious. One area it could be improved is by referencing configuration-driven beans such as the cache and locale interceptors declared in CacheConfiguration and WebConfiguration , to show that DI also wires infrastructure services, not just repositories and controllers in files like src/main/java/org/springframework/samples/petclinic/system/CacheConfiguration,main/java/org/springframework/samples/petclinic/system/WebConfiguration.java. Mentioning of @SpringBootApplication as the trigger for component scanning would further strengthen the explanation by tying bean discovery to the application entry point in src/main/java/org/springframework/samples/petclinic/PetClinicApplication.java. These additions would align the response even more tightly with the full range of DI patterns in the repo. But overall, the model did pretty well despite these issues.

Model B Response Summary

Model B repeats the constructor-injection narrative and cites the same controllers (OwnerController, PetController, VetController, VisitController) and the PetTypeFormatter component under main/java/org/springframework/samples/petclinic/*, matching their constructor-based repository dependencies.It notes the absence of @Autowired/@Inject and correctly attributes bean registration to stereotype annotations and Spring Data proxies for repositories like OwnerRepository in src/main/java/org/springframework/samples/petclinic/owner/OwnerRepository.java†. The summary emphasizes constructor injection benefits but remains fairly high-level. Overall the model did not give an in-depth explanation and i believe the model did not really check the code thoroughly for the explanation. 
Model B Response Feedback

While this model is technically accurate about constructor injection and stereotype-based registration, but Model B stays generic and omits key DI elements present in the code which are obvious and should not be missed at all! It does not even mention the configuration classes that publish infrastructure beans (e.g., cache customization or locale handling), which are central examples of DI beyond the configurations like src/main/java/org/springframework/samples/petclinic/system/CacheConfiguration,src/main/java/org/springframework/samples/petclinic/system/WebConfiguration.java. The response also overlooks the @SpringBootApplication entry point that enables component scanning for all these beans such as in src/main/java/org/springframework/samples/petclinic/PetClinicApplication.java.Compared to Model A, it provides less depth on how DI wiring spans both application endpoints and shared infrastructure.
Overall Preference Justification

Model A is way better because it balances correctness about constructor injection with explicit recognition of repository interfaces and the role of component scanning, closely matching the structure seen in controllers, formatters, and repositories...etc such as src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java,src/main/java/org/springframework/samples/petclinic/owner/PetTypeFormatter.java,src/main/java/org/springframework/samples/petclinic/owner/OwnerRepository.java, Although both models miss some configuration details, Model A surfaces more of the actual DI practices visible in the code and provides a clearer link between stereotypes and injection than Model B, which remains more generic and omits infrastructure wiring examples such as ,src/main/java/org/springframework/samples/petclinic/system/CacheConfiguration.java,src/main/java/org/springframework/samples/petclinic/system/WebConfiguration.java.....etc. Therefore, Model A offers the stronger, more code-grounded explanation in my opinion.
